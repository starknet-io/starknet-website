### TL;DR

* **Комісійні тепер обов'язкові платежі в Testnet, найближчим часом на Mainnet**
* Контрактна фабрика тепер можливо!
* StarkNet представляє класи контрактів
* Делегувати дзвінок замінено на виклик бібліотеки

### Вступ

Ми раді представити StarkNet Alpha 0.9.0! Це важлива версія, в якій StarkNet робить важливі кроки в напрямку зрілості, з істотними доповненнями як до функціонального, так і в протоколі.

**Комісія є обов'язковою**(в даний час тільки за тестовою мережею, до версії 0.9. буде жити в Інтернеті) - будь-який процвітаючий L2 повинен мати власну незалежну систему зборів. Після введення платежів як не обов'язкової можливості в версії 0.8. , зараз ми відчуваємо впевненість у тому, щоб включити їх як основний компонент протоколу та зробити їх обов'язковими. Більше деталей нижче.

Інша значна зміна на рівні протоколу - введення класів контракт та розділення класів. Це дозволяє більш просто використовувати функціональність \`delegate_call\` та розгортання від існуючих договорів, що дозволяє використовувати заводські налаштування для StarkNet.

### Класи контрактів

Виходячи від об'єктно-орієнтованого програмування, ми розрізняємо код контракту та його реалізацію. Ми робимо це шляхом розділення контрактів на класи і екземпляри.

A**контракт**це визначення контракту: його Каїр байткода, підказувати інформацію, точкові імена входу та все, що необхідно однозначно визначити його семантику. Кожен клас визначається його класовим хешем (аналогічно назві класу з мов OP).

**контракт**або просто договір, є розгорнутий контракт відповідає якомусь класу. Зверніть увагу, що лише випадки договорів поводяться як договори, тобто мають власний сховище і можуть бути скликані транзакціями / іншими договорами. Клас контрактів не обов'язково має розгорнутий екземпляр в StarkNet. Вступ до класів надходить з кількома змінами протоколу.

#### транзакція 'Декора'

Ми презентуємо новий тип транзакції до StarkNet: транзакція['declare'](https://docs.starknet.io/docs/Blocks/transactions#declare-transaction), яка дозволяє оголосити контракт**класу.**На відміну від транзакції \`deploy\`, це не розгортає екземпляр цього класу. Держава StarkNet включатиме список оголошених класів. Нові класи можуть бути додані через нову транзакцію \`declare\`.

#### Системні дзвінки "Розгортання" та фонди на контрактних фабриках.

Як тільки клас буде оголошений, тобто відповідна транзакція \`declare` була прийнята, ми можемо розгорнути нові екземпляри цього класу. Щоб завершити, ми використовуємо новий системний виклик \`deploy\`, який приймає наступні аргументи:

* Хеш класу
* Сіль
* Аргументи конструктора

syscall "розгорнути" буде розгорнуто новий екземпляр цього контрактального класу, чинна[адреса](https://docs.starknet.io/docs/Contracts/contract-address)буде визначатися трьома параметрами вище та адресою розгортання (договір, який посилається на системний виклик).

Включаючи розгортання всередині тендерної транзакції, ми дозволяємо нам ціною, а також платити за розгортання, не дозволяючи по-різному ставитися до їх розгортань. Для отримання додаткової інформації про збір за розгортання, див.[документацію](https://docs.starknet.io/docs/Fees/fee-mechanism#deployed-contracts).

Ця функція запроваджує договірні заводи в StarkNet, тому що будь-який контракт може викликати \`deploy\` syscall, створюючи нові контракти.

#### Пересуваючись від 'Делегувати дзвінок' до 'Бібліотечний дзвінок'

Введення класів дозволяє нам вирішувати відому проблему в делегатому механізмі виклику: Коли контракт виконує делегативний заклик до іншого договору, йому потрібний лише клас (його код), а не фактичний екземпляр (його сховище). Якщо вказати конкретний інстанс контракту, при проведенні делегатського виклику - це погана практика (дійсно, він призвев до кількох помилок в контрактах на Ethereum) - потрібно вказати тільки клас.

Системний виклик старих \`delegate_call\` зараз стає застарілим (розгорнутих договорів, які вже розгорнуті, продовжуватимуть функціонувати, але**договори з використанням \`delegate_call\` більше не будуть компілюватися**), і замінюється новим викликом в бібліотеці_виклику, який отримує хеш класу (вже оголошеного класу) замість адреси екземпляра договору. Зверніть увагу, що лише один фактичний контракт бере участь у виклику бібліотеки, тому ми уникаємо неоднозначності між договором на виклик та договором з реалізацією.

#### Нові кінцеві точки API

Ми додали дві нові кінцеві точки до API, дозволяючи отримати дані, пов'язані з класом:

* \`get_class_by_hash\`: повертає визначення класу з заданим хешем
* \`get_class_hash_at\`: повертає класовий хеш розгорнутого контракту з адресою договору

Зверніть увагу, що щоб отримати клас розгорнутого договору безпосередньо, а не проходити далі двома методами, ви можете використовувати стару \`get_full_contract\` кінцеву точку, яка буде перейменована в наступних версіях. Усі згадані вище кінцеві точки також можна використовувати з таблиці[StarkNet CLI](https://docs.starknet.io/docs/CLI/commands).

#### Збори

Ми продовжуємо отримувати обов'язкові платежі в StarkNet, зробивши їх обов'язковими (спочатку в Testnet, а також пізніше в Mainnet) для ``[invoke](https://docs.starknet.io/docs/Blocks/transactions#invoke-function)\` транзакції. Транзакція \`declare\` не потребуватиме комісії в цій точці. Подібно до цього, \`розгортати`` транзакції також не потребуватимуть комісії, однак зверніть увагу, що цей тип транзакцій, швидше за все, буде застарілий у майбутніх версіях.

У цій галузі залишається кілька відкритих питань, найбільш видатних з яких можна стягувати плату за декларації контрактів та розгортання рахунків в StarkNet. Ми будемо вирішувати ці питання в наступних версіях.

### Що далі?

Після нашої дорожньої карти, про яку ми[оголосили в лютому](https://medium.com/starkware/starknet-on-to-the-next-challenge-96a39de7717), ми прагнемо покращити продуктивність StarkNett в цілому, і продуктивність секвенатора, зокрема, для того, щоб отримувати нові відгуки про їхні операції. У наступній версії ми плануємо вводити розпаралелення у послідовність, що дозволяє швидше виробляти блоки.

Наступна основна версія StarkNet буде зосереджена на структурі облікових записів StarkNet, схожому на[ERC-4337](https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a). З цим ми завершили поведінку рахунків в StarkNet, зробивши ще один вагомий крок до масового застосування!