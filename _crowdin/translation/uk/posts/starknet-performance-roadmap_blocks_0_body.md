### TL;DR

* Кількість відкатів на пропускну здатність не обмежена таким же чином, як L1s. Це породжує потенційно набагато вищі ТЕС на випаданні недійсності L2.
* StarkNet дорожня карта автор вирішує ключовий елемент у системі: послідовник.
* Тут ми представляємо дорожню карту для покращення продуктивності:\
  - Паралелізація\
  - нова реалізація ірландського реалізації Каїра\
  - Послідовність повторно реалізації під іржам\ N
* Проверси, випробувані в бою так, як вони є, не є вузьким місцем і не можуть працювати набагато більше, ніж є зараз!

### Вступ

StarkNet працював у Майннет майже рік тому. Ми почали будувати StarkNet завдяки фокусу на функціональності. Тепер, ми перенесемо фокус на покращення продуктивності за допомогою серії кроків, які допоможуть покращити досвід StarkNet.

У цьому повідомленні ми пояснюємо, чому існує широкий спектр оптимізацій, які застосовуються лише для валідних звітів, і ми будемо ділитися нашим планом, щоб виконати ці кроки на StarkNet. Деякі з цих кроків вже реалізовані в StarkNet Alpha 0.10.2, який був випущений на Testnet на Nov 16 і вчора в Mainnet. Але перш ніж ми обговоримо рішення, давайте розглянемо обмеження та їхню справу.

### Блокувати обмеження: постійні розгортання проти L1

Потенційним підходом до підвищення масштабів блокчейнів та збільшення ТЕС було б зняття блокових обмежень (у плані газу/розміру), зберігаючи час блокування сталим. Це вимагатиме більше зусиль виробників блоків (валідатори L1, послідовники L2) і таким чином вимагає більш ефективної реалізації цих компонентів. З цією метою ми перенесемо увагу на оптимізацію "StarkNet", яку більш детально описуємо у наступних розділах.

Природні питання тут виникають. Чому послідовні оптимізації обмежуються валідними дозволами, тобто, чому ми не можемо застосувати ті ж вдосконалення на L1 та уникнути складностей повного розгортання достовірності? У наступній секції ми стверджуємо, що існує принципова різниця між двома, дозволяє використовувати широкий спектр оптимізацій на L2, які не застосовуються до L1.

### Чому L1 проходить через обмеження?

На жаль, зняття обмежень на блокування на L1 страждає від значного падіння. Збільшення темпів зростання ланцюга, ми також збільшує вимоги з повних вузлів, хто намагається йти в ногу з останнім станом. Оскільки L1 повні вузли повинні повторно виконати всю історію, високе збільшення розміру блоку (в плані газу) робить на них значний штам знову до слабших машин, що покидають систему і залишають можливість запускати повні вузли лише до великої кількості сутностей. Як результат, користувачі не зможуть перевірити себе та взяти участь у мережі ненадійно.

Це залишає нам розуміння того, що L1 проходження має бути обмеженим, щоб підтримувати справді децентралізовану та безпечну систему.

### Чому ті самі бар'єри не впливають на розгортання достовірності?

**Лише при розгляді перспективи повного вузла, ми бачимо справжню потужність, запропоновану валідними рухами.**L1 повний вузол необхідно повторно виконати всю історію, щоб забезпечити правильність поточної держави. StarkNet вузли потребують лише перевірки доведення доказів STARK, і ця перевірка обмежена експоненціальними ресурсами. Зокрема, синхронізація з нуля не повинна передбачати виконання; вузол може отримати дамп поточного стану від учасників і перевірити лише через доказ того, що даний стан дійсний. Це дозволяє нам збільшити пропускну здатність мережі, не збільшуючи вимоги від повного вузла.

Тому ми підходимо до висновку, що секвенсер L2 посідає весь спектр оптимізацій, які неможливі для L1.

### Продуктивність дорожньої карти попереду

У наступних розділах ми обговорюємо, які з них зараз заплановані на послідовність StarkNet.

### Паралізація Секвенсера

Першим кроком на нашій дорожній карті було встановлення паралелізації виконанню транзакцій. Він був введений в StarkNet alpha 0.10.2, який був випущений з дому в Mainnet. Тепер ми наштовхуємось на те, що є паралелізація. Це напівтехнічний розділ, щоб продовжити дорожню карту, стрибаємо до наступного розділу).

То що означає "розпаралелення операцій"? Наївно, виконання блоку транзакцій паралельно неможливе, тому що різні транзакції можуть бути залежними. Це намальовано на прикладі. Розглянемо блок з трьома транзакціями від одного користувача:

* Транзакція А: своп USDC для ETH
* Транзакція B: оплата ETH за NFT
* Транзакція C: замінити USDT для BTC

Зрозуміло, що Tx A має відбуватися до букви В, але Tx C абсолютно не залежить від обох іх. І може бути виконаним паралельно. Якщо кожна транзакція вимагає 1 секунду до виконання, тоді час виробництва блоків можна зменшити з 3 секунд до 2 секунд шляхом впровадження паралелізації.

Проблема в тому, що ми не знаємо про залежності від транзакції заздалегідь. На практиці тільки коли ми виконуємо операцію В з нашого прикладу, ми бачимо, що вона спирається на зміни, внесені транзакцією А. Більш формально, залежність випливає з того, що транзакція В читається від клітинок зберігання, до яких написана транзакція А. Ми можемо розглядати операції як формування графіку залежності, де є край від транзакції A до транзакції B iff A записує до клітини сховища, який читає В, і таким чином має бути виконане до В. На наступному зображенні зображений приклад такого графіку залежності:

![](https://miro.medium.com/max/641/0*I-qGgxdJJmqmgZWM)

У наведеному вище прикладі кожен стовпець може бути виконаний паралельно, і це оптимальна домовленість (хоча й наївно, ми б виконували угоди 1–9 послідовно).

Щоб подолати той факт, що відомий графік залежностей заздалегідь, ми вводимо***оптимістичну паралелізацію***в дусі[BLOCK-STM](https://malkhi.com/posts/2022/04/block-stm/)розроблено Aptos Labs, до послідовника StarkNet. В цій парадигмі ми оптимістично намагаємося виконувати операції паралельно, і повторно виконуємо після пошуку зіткнення. Наприклад, ми можемо виконувати операції 1–4 від позначки 1 паралельно, тільки щоб з'ясувати, що Tx4 залежить від Tx1. Отже, його виконання було марним (ми запускали його відносно того ж стану, що ми вели проти Tx1, поки ми мали б запустити його проти держави, що виникає внаслідок застосування Tx1). В такому випадку ми здійснимо перевиконання Tx4.

Зверніть увагу, що ми можемо додати багато оптимізацій поверх оптимістичної паралелізації. Наприклад, замість того, щоб наївно чекати, поки кожне виконання закінчується, ми можемо перервати виконання моменту, коли ми знаходимо залежність, яка його недійсна.

Інший приклад - оптимізувати вибір, з яких операцій перевиконувати. Припустимо, блок, який складається з усіх транзакцій №1 подається у послідовник з п'ятьма ядрами ЦП. По-перше, ми намагаємося виконувати транзакції 1–5 паралельно. Якщо порядок завершення: Tx2, Tx3, Tx4, Tx1, та Tx5, тоді ми знайдемо залежність від Tx1 →Tx4 тільки після того, як Tx4 вже буде виконано, — що вказує на те, що Tx4 буде перевиконаний. Наївно, ми можемо також переосмислити Tx5, оскільки він може поводитися інакше, враховуючи нове виконання Tx4. Однак, замість того, щоб просто перевиконувати всі операції після сьогоднішнього затвердженого Tx4, ми можемо запобігти графіку залежності, побудованому з транзакцій, виконання яких вже припинилося і лише виконуються операції, що залежать від Tx4.

### Нова реалізація Rust для Cairo-VM

Розумні договори в StarkNet написані в Каїрі і виконуються всередині Каїру, в якому специфікація з'являється в газеті[Каїр](https://eprint.iacr.org/2021/1063.pdf). У даний час послідовник використовує[python реалізацію](https://github.com/starkware-libs/cairo-lang/tree/master/src/starkware/cairo/lang/vm)Кайро-VM. Для оптимізації роботи з імплементацією у форматі VM, ми запустили намагання переписати VM-радіо під час руху. Завдяки чудовій роботі[Lambdaclass](https://lambdaclass.com/), які є безцінними командами екосистеми StarkNet, незабаром долучилися до фруктів.

Реалізація іржі VM,[cairo-rs](https://github.com/lambdaclass/cairo-rs)тепер може виконувати власний код Каїру. Наступний крок - це виконання виконання і інтеграції розумних контрактів з пітонічним послідовником. Як тільки інтегровані з Каїром, очікується, що продуктивність послідовника значно покращиться.

### Секвенсер повторно реалізація в Rust

Наш перехід від Python до rust до покращення продуктивності не обмежується каїро VM. Поряд із змінами вищезгаданого, ми плануємо перезаписати секвенсер з нуля під час пилу. На додаток до внутрішніх переваг Rust, це надає можливість іншим оптимізаціям послідовності. Прокладання пари - ми можемо насолоджуватися перевагами кайро-р без накладання зв'язку з пітоном, і ми можемо повністю змінити зовнішній вигляд так, як стан зберігається та має доступ (який базується на основі структури[Патрічія-Тріє](https://docs.starknet.io/documentation/develop/State/starknet-state/#state_commitment).

### А як щодо партнерів?

Протягом усієї цієї посади ми не згадували, мабуть, найвідоміший елемент роликів валідності - постачальник. Можна собі уявити, що це, мабуть, найскладніший компонент архітектури, має бути вузьким і таким чином, центром оптимізації. Цікаво, що зараз саме більш «стандарти» є вузьким місцем СтаркНет. Сьогодні, особливо з[рекурсивними доведення](https://medium.com/starkware/recursive-starks-78f8dd401025), ми можемо вводити набагато більше транзакцій, ніж поточний трафік за допомогою Testnet/Mainnet в доказі. Насправді, сьогодні блоками StarkNet перевірені поряд з трансакціями StarkEx, де останні іноді можуть понести кілька сотень тисяч мін НФТ.

### Summary

Паралелізація, іржа, і ще більше — підготуйтеся до вдосконаленого ТЕС у майбутніх версіях StarkNet.