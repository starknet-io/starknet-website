### TL;DR

* **Плата теперь обязательна для Testnet, вскоре в Mainnet**
* Контрактный рисунок теперь возможен!
* StarkNet представляет классы контрактов
* Вызов делегата заменен библиотечным вызовом

### Введение

Мы рады представить вам StarkNet Alpha 0.9.0! Это важная версия, в которой StarkNet предпринимает значительные шаги в направлении зрелости, с существенными дополнениями к функциональности и проектированию протокола.

**Комиссия обязательна**(в настоящее время только для Testnet, до версии 0.9. будет жить на Майннете) — любая процветающая L2 должна иметь свою собственную независимую систему сборов. После введения комиссии в качестве дополнительной функции в версии 0.8. , мы теперь уверены в том, что они будут включать их в качестве основного компонента протокола и делать их обязательными. Более подробная информация ниже.

Другим существенным изменением на уровне протокола является введение договорных классов и разделение классов/экземпляров. Это позволяет более просто использовать функциональность \`delegate_call\` и развертывание из существующих контрактов, что позволяет использовать шаблон фабрики в StarkNet.

### Контрактные уроки

Опираясь на объектно-ориентированное программирование, мы проводим различие между договорным кодом и его реализацией. Мы делаем это, разделяя контракты на классы и экземпляры.

**класс контракта**- это определение контракта: его Каирский байтекод, подсказка информации, имена точек входа, и все, что необходимо для однозначного определения семантики. Каждый класс определяется по хэшу класса (аналогичному имени класса из языков OOP).

**Контракт**или просто контракт является развернутым контрактом, соответствующим какому-либо классу. Заметим, что контракты действуют только в качестве контрактов, т.е. имеют свое собственное хранение и вызываются сделками/другими контрактами. Класс контракта не обязательно имеет развернутый экземпляр в StarkNet. Внедрение классов включает в себя несколько изменений протокола.

#### Объявление транзакции

Мы представляем транзакцию нового типа StarkNet: транзакцию[«объявлять»](https://docs.starknet.io/docs/Blocks/transactions#declare-transaction), которая позволяет объявить класс**контракта.**В отличие от \`deploy\` транзакции, это не развертывает экземпляр этого класса. В штат StarkNet будет включен список объявленных классов. Новые классы могут быть добавлены с помощью новой \`declare\` транзакции.

#### Фабрики вызовов и контрактов «Развертывание системы».

Как только класс объявлен, то есть принята соответствующая транзакция \`declare\`, мы можем развертывать новые экземпляры этого класса. С этой целью мы используем новый \`deploy\` системный вызов, который принимает следующие аргументы:

* Хэш класса
* Соль
* Аргументы конструктора

Установка syscall приведет к развертыванию нового экземпляра этого класса контракта, который[адрес](https://docs.starknet.io/docs/Contracts/contract-address)будет определяться тремя параметрами выше и адресом развертывания (контракт, на который был вызван системный вызов).

Включая развертывание внутри транзакции позволяет нам ценять и взимать плату за развертывание, без необходимости рассматривать развертывание и вызовы по-другому. Дополнительную информацию о плате за развертывание можно найти на[в документации](https://docs.starknet.io/docs/Fees/fee-mechanism#deployed-contracts).

Эта функция вводит фабрики контрактов в StarkNet, так как любой контракт может вызвать \`deploy\` syscall, создавая новые контракты.

#### Переход из списка делегатов на библиотечный звонок

Внедрение классов позволяет нам решить известную проблему в механизме вызова делегата Ethereum: когда контракт выполняет делегат вызова другому контракту, ему нужен только свой класс (его код), а не фактический экземпляр (его хранилище). Необходимость уточнения конкретного случая контракта при вызове делегата поэтому является неэффективной практикой (действительно, он привел к нескольким ошибкам в Ethereum договорах) — только класс должен быть указан.

Старый \`delegate_call\` системный вызов становится устаревшим (старые контракты, которые уже развернуты, будут продолжать функционировать, но**контрактов с использованием \`delegate_call\` больше не будет компилировать**), и заменяется новым системным вызовом library_call, который вместо адреса экземпляра контракта получает хэш класса (ранее объявленного класса). Заметьте, что только один реальный контракт связан с библиотечным звонком, поэтому мы избегаем двусмысленности между звонящим контрактом и имплементационным договором.

#### Новые конечные точки API

В API добавлены две новые конечные точки, позволяющие извлечь данные, связанные с классами:

* \`get_class_by_hash\`: возвращает определение класса с учетом хэша класса
* \`get_class_hash_at\`: возвращает хэш класса развернутого контракта, учитывая адрес контракта

Обратите внимание, что для получения класса развернутого контракта напрямую, а не для использования двух вышеперечисленных методов, вы можете использовать старую конечную точку \`get_full_contract\`, которая будет переименована в будущие версии. Все перечисленные выше конечные точки также можно использовать из[StarkNet CLI](https://docs.starknet.io/docs/CLI/commands).

#### Комиссионные

Мы продолжаем включать комиссию в StarkNet, что делает их обязательными (сначала на Testnet, а затем и на Mainnet) для ``[invoke](https://docs.starknet.io/docs/Blocks/transactions#invoke-function)\`. Транзакция \`declare\` на данный момент не требует комиссий. Аналогично, \`deploy`` транзакции также не потребуют комиссии, однако, обратите внимание, что этот тип транзакции скорее всего устареет в будущих версиях.

В этой области остается несколько открытых вопросов, наиболее заметных из которых заключаются в том, как взимать плату за заключение контрактов и размещать счета StarkNet. Мы рассмотрим эти вопросы в будущих версиях.

### Что дальше?

Следуя нашей дорожной карте, которую мы[объявили в феврале](https://medium.com/starkware/starknet-on-to-the-next-challenge-96a39de7717), мы привержены делу повышения производительности StarkNet в целом, и особенно производительности последовательности, чтобы пользователи быстрее обратной связи об их транзакциях. В следующей версии мы планируем параллелизовать последовательность, что позволит ускорить производство блоков.

Следующая основная версия StarkNet сосредоточит свое внимание на структуре счетов StarkNet, таким образом, чтобы это было похоже на[ERC-4337](https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a). С этим мы завершим работу над тем, как ведут счета StarkNet, сделав еще один важный шаг к массовому усыновлению!