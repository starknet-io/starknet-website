### TL;DR

* Плата теперь обязательна в тестовой сети, скоро в основной сети
* Контрактная фабрика теперь возможна!
* Starknet вводит контрактные классы
* Вызов делегата заменен вызовом библиотеки

### вступление

Мы рады представить Starknet Alpha 0.9.0! Это важная версия, в которой Starknet делает значительные шаги к зрелости, внося существенные дополнения как в функциональность, так и в структуру протокола.

Сборы являются обязательными (в настоящее время только в тестовой сети, пока версия 0.9.0 не будет запущена в основной сети) — любой процветающий L2 должен иметь свою собственную независимую систему сборов. После введения сборов в качестве дополнительной функции в версии 0.8.0 мы теперь уверены, что включим их в качестве основного компонента протокола и сделаем их обязательными. Подробнее ниже.

Еще одним значительным изменением на уровне протокола является введение классов контрактов и разделения класса/экземпляра. Это позволяет более просто использовать функциональность \`delegate_call\` и развертывания из существующих контрактов, позволяя использовать заводской шаблон в Starknet.

### Классы контрактов

Черпая вдохновение из объектно-ориентированного программирования, мы различаем код контракта и его реализацию. Мы делаем это, разделяя контракты на классы и экземпляры.

Класс контракта — это определение контракта: его байт-код Cairo, информация о подсказках, имена точек входа и все необходимое для однозначного определения его семантики. Каждый класс идентифицируется своим хешем класса (аналогично имени класса в языках ООП).

Экземпляр контракта или просто контракт — это развернутый контракт, соответствующий некоторому классу. Обратите внимание, что только экземпляры контрактов ведут себя как контракты, т. е. имеют собственное хранилище и могут вызываться транзакциями/другими контрактами. Класс контракта не обязательно имеет развернутый экземпляр в Starknet. Введение классов связано с несколькими изменениями протокола.

#### «Объявить» транзакцию

Мы представляем в Starknet новый тип транзакции: транзакцию ['declare'](https://docs.starknet.io/docs/Blocks/transactions#declare-transaction) , которая позволяет объявлять класс контракта. В отличие от транзакции \`deploy\`, это не развертывает экземпляр этого класса. Состояние Starknet будет включать в себя список объявленных классов. Новые классы могут быть добавлены через новую транзакцию «declare».

#### Фабрики системных вызовов и контрактов «Развертывание».

Как только класс объявлен, то есть принята соответствующая транзакция «declare», мы можем развернуть новые экземпляры этого класса. С этой целью мы используем новый системный вызов \`deploy\`, который принимает следующие аргументы:

* Хэш класса
* Соль
* Аргументы конструктора

Затем системный вызов «deploy» развернет новый экземпляр этого класса контракта, чей адрес [](https://docs.starknet.io/docs/Contracts/contract-address) будет определяться тремя указанными выше параметрами и адресом развертывателя (контракт, вызвавший системный вызов).

Включение развертываний в транзакцию вызова позволяет нам оценивать и взимать плату за развертывание без необходимости по-разному обрабатывать развертывания и вызовы. Дополнительные сведения о плате за развертывание см. в [документации](https://docs.starknet.io/docs/Fees/fee-mechanism#deployed-contracts).

Эта функция вводит фабрики контрактов в Starknet, поскольку любой контракт может вызывать системный вызов «развернуть», создавая новые контракты.

#### Переход от «вызова делегата» к «вызову библиотеки»

Введение классов позволяет нам решить известную проблему в механизме вызова делегата Ethereum: когда контракт выполняет вызов делегата для другого контракта, ему нужен только его класс (его код), а не фактический экземпляр (его хранилище). Поэтому необходимость указывать конкретный экземпляр контракта при выполнении вызова делегата является плохой практикой (действительно, это привело к нескольким ошибкам в контрактах Ethereum) — нужно указать только класс.

Старый системный вызов \`delegate_call\` теперь становится устаревшим (старые контракты, которые уже развернуты, будут продолжать функционировать, но контракты, использующие \`delegate_call\`, больше не будут компилироваться), и заменяется новым системным вызовом library_call, который получает хэш класса (ранее объявленного класса) вместо адреса экземпляра контракта. Обратите внимание, что в библиотечном вызове задействован только один фактический контракт, поэтому мы избегаем двусмысленности между вызывающим контрактом и контрактом реализации.

#### Новые конечные точки API

Мы добавили в API две новые конечные точки, позволяющие извлекать данные, относящиеся к классам:

* \`get_class_by_hash\`: возвращает определение класса с учетом хэша класса.
* \`get_class_hash_at\`: возвращает хэш класса развернутого контракта с учетом адреса контракта.

Обратите внимание, что для получения класса развернутого контракта напрямую, а не через два описанных выше метода, вы можете использовать старую конечную точку get_full_contract, которая будет переименована в будущих версиях. Все конечные точки, упомянутые выше, также можно использовать из CLI [Starknet](https://docs.starknet.io/docs/CLI/commands).

#### Сборы

Мы продолжаем включать сборы в Starknet, делая их обязательными (сначала в Testnet, а затем и в Mainnet) для \[invoke](https://docs.Starknet.io/docs/Blocks/transactions#invoke-function)\ транзакций. На данный момент транзакция «объявления» не требует комиссий. Точно так же транзакции «развертывания» также не будут требовать платы, однако обратите внимание, что этот тип транзакции, скорее всего, будет объявлен устаревшим в будущих версиях.

В этой области остается несколько открытых вопросов, наиболее важными из которых являются взимание платы за объявления контрактов и развертывание учетных записей Starknet. Мы решим эти проблемы в будущих версиях.

### Что дальше?

Следуя нашей дорожной карте, о</a>

, мы стремимся улучшить производительность Starknet в целом и производительность секвенсора в частности, чтобы пользователи могли быстрее получать отзывы об их транзакциях. В следующей версии мы планируем ввести параллелизацию в секвенсор, что позволит ускорить производство блоков.</p> 

Следующая основная версия Starknet будет сосредоточена на структуре учетных записей Starknet, аналогично [ERC-4337](https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a). Таким образом, мы доработали поведение учетных записей Starknet, сделав еще один важный шаг к массовому внедрению!