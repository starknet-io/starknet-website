### TL;DR

* **Каир 1.0 с открытым исходным кодом! Это только первый шаг к открытию стека StarkNet.**
* Теперь мы представляем[первый взгляд](https://github.com/starkware-libs/cairo)на компилятор Cairo 1.0. Теперь вы можете начать экспериментировать с базовым кодом Cairo 1.0.
* Cairo 1.0 по своей сути очень похож на Rust
* Считайте это первым вкусом, а не релизом. На подходе другие улучшения. Первая версия компилятора запланирована на начало первого квартала следующего года.
* Cairo 1.0 пока не поддерживается в StarkNet. Он будет поддерживаться в StarkNet в первом квартале следующего года.

### вступление

В 2020 году мы выпустили[Cairo](https://eprint.iacr.org/2021/1063.pdf), полный по Тьюрингу язык программирования, поддерживающий проверяемые вычисления. Cairo начинался как язык ассемблера и постепенно становился все более выразительным. Два месяца назад мы анонсировали[Cairo 1.0](https://medium.com/starkware/cairo-1-0-aa96eefb19a0), который решает некоторые важные проблемы в текущей ситуации:

* Хотя синтаксис Cairo претерпел значительные улучшения с момента его создания, опыт разработчиков всегда можно улучшить. Cairo 1.0 — это полностью типизированный язык, вдохновленный ржавчиной, который делает написание той же логики намного проще и менее подверженным ошибкам.
* Существующий компилятор разработан в том же репозитории, что и сам StarkNet, что затрудняет отслеживание языковых изменений. Компилятор Cairo 1.0 написан с нуля, что позволяет ускорить разработку функций и обеспечить более активное участие сообщества.
* Каждое вычисление теперь доказуемо. В настоящее время программа Cairo может дать сбой при определенных входных данных (например, при достижении инструкции \`assert 1=2\` в какой-либо ветке вычислений), что сделает вычисление недоказуемым. С Cairo 1.0 программы доказуемы во всех возможных ответвлениях. Это особенно важно для защиты от DOS и сопротивления цензуре в StarkNet.

Сегодня мы отмечаем первую веху в достижении вышеуказанных целей, поскольку мы переносим разработку в общедоступный репозиторий и**Cairo 1.0 с открытым исходным кодом!**Теперь разработчики впервые могут компилировать и выполнять простые программы Cairo 1.0. Это позволяет разработчикам начать экспериментировать с Cairo 1.0 и постепенно привыкать к новым функциям, даже если на данном этапе они еще не могут реализовать их в StarkNet.

### Текущие возможности

В настоящее время вы можете компилировать и выполнять базовые нативные программы Cairo. Хотя многие улучшения синтаксиса/языка все еще находятся в стадии разработки, это позволяет привыкнуть к Cairo 1.0 и получать обновления по мере их появления.

**Обратите внимание, что написание контрактов StarkNet по-прежнему не поддерживается.**Синтаксис StarkNet (переменные хранения/вызовы контрактов/события и другие системные вызовы) будет добавлен в ближайшие недели.

### Примеры кода

Чтобы проиллюстрировать различия между старым синтаксисом и Cairo 1.0, мы решили показать несколько различных реализаций/вариантов нахождения n-го числа Фибоначчи.

### Пример I: сопоставление выражений

В Cairo 1.0 вы можете использовать rust-подобные выражения[match](https://doc.rust-lang.org/rust-by-example/flow_control/match.html?highlight=match#match). Вы больше не будете бояться операторов if/else, которые могут привести к аннулированию ссылки!

![](/assets/code01.png)

### Пример II: типы данных

В то время как Cairo 0 работал с маркерами и указателями, в Cairo 1.0 у нас есть встроенный доступ к сложным типам данных в языке. Ниже вы можете найти пример, который генерирует массив из первых n чисел Фибоначчи.

![](/assets/code02.png)

Как вы можете видеть выше, вместо того, чтобы работать напрямую с указателями памяти, мы используем `Array::<felt>тип \` и функция \`array_append\`.

### Пример III: владение структурами &

Следующий код иллюстрирует использование структур в Cairo 1.0.

![](/assets/code03.png)

> Следующий абзац предназначен для рустообразных среди зрителей. Cairo 1.0 управляет памятью аналогично Rust. В частности, он использует понятия владения[и заимствования](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html). Таким образом, обратившись к члену структуры \`FibResult\` (в данном случае, \`result.value\`), мы переместили \`result\`, что означает, что если FibResult не может быть скопирован, мы не можем получить к нему доступ снова в \`result.index\`. Чтобы преодолеть это, мы добавляем атрибут \`#\[derive(Copy)]\` типа \`FibResult\`. В будущих версиях мы добавим автоматическую деконструкцию для структур. Это позволит переместить право собственности на одного члена, не касаясь других (в частности, приведенный выше код будет компилироваться, даже если \`FibResult\` не имеет атрибута копирования).

**В частности, обратите внимание, что Cairo 1.0 полностью абстрагируется от исходной (не детерминированной только для чтения) модели памяти Cairo.**

## Пример IV: распространение ошибки

Следующий код вычисляет n-е число Фибоначчи, но, в отличие от предыдущих примеров, все входные данные имеют тип uint128. Обратите внимание, что это решает основную проблему обработки юнитов в Cairo 0. Здесь uint128 (и в будущем uint256) являются нативными типами.

![](/assets/0_s8bhjf_ade3carmi.png)

Добавление двух 128-битных целых чисел может привести к переполнению. В приведенном выше коде используется перечисление[Option](https://doc.rust-lang.org/rust-by-example/std/option.html)и оператор вопросительного знака[](https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html)для обработки случая переполнения в одном из промежуточных дополнений. Сравните это с[текущим](https://github.com/starkware-libs/cairo-lang/blob/9889fbd522edc5eff603356e1912e20642ae20af/src/starkware/cairo/common/uint256.cairo#L31)синтаксисом добавления uint256, где функция unit256_check должна была быть вызвана, чтобы гарантировать надежность. Кроме того, в ближайшем будущем мы добавим в язык понятие «паника» (аналогично макросу[panic](https://doc.rust-lang.org/rust-by-example/std/panic.html)в rust), а простые ошибки вроде переполнения сложения будут неотлавливаемыми и распространяться автоматически, а это значит, что вам не придется использовать \`Option\` или \`?\` при добавлении uints.

## Попробуй сам

Теперь вы можете компилировать и запускать поддерживаемые в настоящее время программы Cairo 1.0! Следуйте этим[инструкциям](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-runner)о том, как использовать команду «cairo-run». Обратите внимание, что под капотом для исполнения используется[Rust Cairo VM](https://github.com/lambdaclass/cairo-rs), разработанная[Lambdaclass](https://lambdaclass.com/).

Вы можете найти больше примеров, которые помогут вам начать работу[здесь](https://github.com/starkware-libs/cairo2/tree/main/examples). Обратите внимание, что это только первый взгляд на разработку компилятора; в ближайшие недели мы улучшим интерфейс командной строки вместе с компилятором.

## Планы на будущее

Первая версия компилятора, выпуск которой запланирован на начало первого квартала, направлена на поддержку всех существующих функций StarkNet в Cairo 1.0. Кроме того, мы работаем над расширением возможностей компилятора Cairo 1.0. В ближайшие недели вы можете ожидать:

* Возможности StarkNet — написание смарт-контрактов и использование системных вызовов.
* Петли
* Новые библиотечные функции
* Улучшенный языковой сервер
* Родное представление о газе StarkNet

Обязательно следите за обновлениями и следите за прогрессом компилятора!