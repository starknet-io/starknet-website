### TL;DR

* **Cairo 1.0 является открытым исходным кодом! Это всего лишь первый шаг к open-sourcing стеку StarkNet.**
* Теперь мы представляем[первый взгляд](https://github.com/starkware-libs/cairo)на процессор Каира 1.0. Теперь вы можете начать эксперименты с базовым кодом Cairo 1.0
* Каир 1,0 в его ядре очень похож на ржавчину
* Подумайте, что это первый вкус, а не релиз. В настоящее время ведется работа над новыми усовершенствованиями. Первая версия компилятора запланирована на начало следующего года на Q1.
* Cairo 1.0 пока не поддерживается в StarkNet. Она будет поддерживаться на StarkNet в Q1 в следующем году.

### Введение

В 2020 году мы выпустили[Каир](https://eprint.iacr.org/2021/1063.pdf), язык программирования Туринг с поддержкой поддающихся проверке вычислений. Каир начал как язык сборки и постепенно стал более выразительным. Два месяца назад мы объявили о[Каире 1.0](https://medium.com/starkware/cairo-1-0-aa96eefb19a0), в котором рассматриваются некоторые основные проблемы в текущей ситуации:

* В то время как синтаксис Каира с момента его создания заметно улучшился, опыт разработчиков всегда может улучшиться. Cairo 1.0 - это произносимый на русском языке полностью тип, что делает запись той же логики гораздо проще и менее подвержен ошибкам.
* Существующий компилятор разработан в том же репозитории, что и сам StarkNet, что затрудняет отслеживание языковых изменений. Компилятор Cairo 1.0 написан с нуля, что позволяет ускорить разработку возможностей и расширить участие сообщества.
* Каждый расчет теперь вполне возможен. В настоящее время программа Каира может не работать с определенными вставками (например, путем получения инструкции \`assert 1=2\` в некоторых ветвях вычислений), что делает вычисление недопустимым. С Cairo 1.0 программы доказываются во всех возможных филиалах. Это особенно важно для защиты DOS и сопротивления цензуре в StarkNet.

Сегодня мы отмечаем первую веху в достижении вышеупомянутых целей, когда мы переходим к развитию публичного репо, и**с открытым исходным кодом Каир1. !**Разработчики теперь могут впервые компилировать и выполнять простые Cairo 1.0 программы. Это позволяет разработчикам начать эксперименты с Cairo 1. и постепенно привыкли к новым функциям, даже если на этой фазе они пока не смогут реализовать их на StarkNet.

### Текущие возможности

В настоящее время вы можете компилировать и выполнять основные Cairo программы. Хотя многие улучшения синтаксиса/языка все еще продолжаются, это позволяет использовать Cairo 1.0 и наслаждаться обновлениями по мере их появления.

**Обратите внимание, что написание контрактов StarkNet все еще не поддерживается.**Синтаксис StarkNet (переменные хранилища / вызов контрактов / событий и других системных вызовов) будет добавлен в ближайшие недели.

### Примеры кода

Чтобы проиллюстрировать различия между старым синтаксисом и Каиро1. , мы выбрали показать несколько различных реализаций/вариантов поиска номера N’th Fibonacci.

### Пример I: Совпадения выражений

В Каире 1.0 вы можете использовать строчные[совпадение](https://doc.rust-lang.org/rust-by-example/flow_control/match.html?highlight=match#match)выражений. Больше не боятся, если утверждения, которые могут привести к отзыву ссылок!

![](/assets/code01.png)

### Пример II: Типы данных

В то время как Каир 0 работал с фельтами и указателями, в Каире 1.0 мы имеем родной доступ к сложным типам данных на языке. Ниже приведен пример создания массива первых N Фибоначчи чисел.

![](/assets/code02.png)

Как вы можете видеть выше, а не работать непосредственно с указателями памяти, мы используем `Array::<felt>Тип \` и \`array_append\`function.

### Пример III: построен & владелец

Следующий код иллюстрирует использование структур в Каире 1,0.

![](/assets/code03.png)

> Следующий абзац предназначен для рустайцев из числа аудитории. Cairo 1.0 управляет памятью подобно ржавчине. В частности, он использует понятия[владения и заимствования](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html). Таким образом, пользуясь доступом к участнику \`FibResult\` структурирована (в данном случае \`result. alue\`), мы переместили \`result\`, что означает, что если FibResult не будет копироваться, мы не сможем получить доступ к нему снова в \`result.index\`. Чтобы преодолеть эту проблему, добавьте атрибут \`#\[derive(Copy)]\` типа \`FibResult\`. В будущих версиях мы добавим автоматическую разборку конструкций. Это позволит перенести владение одним участником, не коснувшись других (в частности, приведенный выше код компилируется, даже если \`FibResult\` не имеет атрибута копирования).

**В частности, обратите внимание на то, что Каир 1.0 полностью абстрагируется от оригинальной (ни одна детерминистская модель памяти) модели памяти Каира.**

## Пример IV: Ошибка распространения

Следующий код вычисляет номер N'th Fibonacci, но в отличие от предыдущих примеров, все входы типа uint128. Заметим, что это решает большую боль точку обработки труб в Каире 0. Здесь uint128 (и в будущем uint256) являются родными типами.

![](/assets/0_s8bhjf_ade3carmi.png)

Добавление двух 128 битных целых чисел может привести к переполнению. Вышеприведенный код использует[Option enum](https://doc.rust-lang.org/rust-by-example/std/option.html), а[оператор вопросительного знака](https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html)для обработки случая переполнения в одном из промежуточных добавлений. Сравните это с[текущим](https://github.com/starkware-libs/cairo-lang/blob/9889fbd522edc5eff603356e1912e20642ae20af/src/starkware/cairo/common/uint256.cairo#L31)синтаксисом добавления uint256, где функция unit256_check должна была быть вызвана, чтобы гарантировать надежность. Кроме того, в ближайшем будущем мы добавим понятие \`panic\` в язык (похожий на[панику](https://doc.rust-lang.org/rust-by-example/std/panic.html)макроса в рве), и такие простые ошибки, как переполнение добавления, будут невостребованы и распространяться автоматически, что означает, что вам не придется использовать \`Option\` или \`? ` при добавлении uints.

## Попробовать себя

Теперь вы можете скомпилировать и запустить поддерживаемые Cairo 1.0 программы! Следуйте этим[инструкциям](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-runner)о том, как использовать команду \`cairo-run\`. Заметьте, что в настоящее время для выполнения используются[Rust Cairo VM](https://github.com/lambdaclass/cairo-rs), разработанные[Lambdaclass](https://lambdaclass.com/).

Вы можете найти больше примеров, чтобы помочь вам начать[здесь](https://github.com/starkware-libs/cairo2/tree/main/examples). Заметим, что это только первый шаг к разработке компилятора, в ближайшие недели мы улучшим CLI наряду с компилятором.

## Планы на будущее

Основное внимание в первой версии Компилятора, запланированной на начало Q1, уделяется поддержке всех существующих функциональных возможностей StarkNet в Cairo 1.0. Кроме того, мы работаем над расширением возможностей Cairo 1.0. В ближайшие недели можно ожидать:

* StarkNet — возможность написания смарт-контрактов и использования системных вызовов.
* Циклы
* Новые библиотечные функции
* Улучшен сервер языков
* Понятие газа StarkNet

Обязательно следите за работой компилятора!