### TL;DR

* Сводки валидности не имеют ограничений по пропускной способности, как L1. Это приводит к потенциально гораздо более высокому показателю TPS при свертывании достоверности L2.
* Дорожная карта производительности Starknet касается ключевого элемента системы: секвенсора.
* Мы представляем здесь дорожную карту для улучшения производительности:\
  — Распараллеливание Sequencer\
  — Новая реализация rust для виртуальной машины Cairo\
  — Повторная реализация Sequencer в rust\
* Испытанные в бою пруверы не являются узким местом и могут справиться с гораздо большим, чем сейчас!

### вступление

Старкнет был запущен в основной сети почти год назад. Мы начали создавать Starknet, сосредоточившись на функциональности. Теперь мы сместим акцент на повышение производительности с помощью ряда шагов, которые помогут улучшить работу Starknet.

В этом посте мы объясним, почему существует широкий спектр оптимизаций, которые применимы только к сверткам достоверности, и поделимся нашим планом реализации этих шагов в Starknet. Некоторые из этих шагов уже реализованы в Starknet Alpha 0.10.2, которая была выпущена в тестовой сети 16 ноября и вчера в основной сети. Но прежде чем мы обсудим решения, давайте рассмотрим ограничения и их причину.

### Ограничения блока: свертки достоверности по сравнению с L1

Потенциальным подходом к повышению масштабируемости блокчейна и увеличению TPS может быть снятие ограничений блока (с точки зрения газа/размера) при сохранении постоянного времени блока. Это потребует больше усилий от производителей блоков (валидаторов на L1, секвенсоров на L2) и, следовательно, требует более эффективной реализации этих компонентов. С этой целью мы теперь сместим акцент на оптимизацию секвенсора Starknet, которую мы опишем более подробно в следующих разделах.

Здесь возникает естественный вопрос. Почему оптимизация секвенсора ограничивается сверткой достоверности, то есть почему мы не можем реализовать те же улучшения на L1 и полностью избежать сложностей свертки достоверности? В следующем разделе мы утверждаем, что между ними существует фундаментальное различие, позволяющее проводить широкий спектр оптимизаций на уровне L2, неприменимых к уровню L1.

### Почему пропускная способность L1 ограничена?

К сожалению, снятие блочных ограничений на уровне L1 сопряжено с серьезной ошибкой. Увеличивая скорость роста цепочки, мы также увеличиваем требования со стороны полных узлов, которые пытаются не отставать от самого последнего состояния. Поскольку полные узлы L1 должны повторно выполнять всю историю, значительное увеличение размера блока (с точки зрения газа) создает для них значительную нагрузку, что снова приводит к тому, что более слабые машины выпадают из системы и оставляют возможность запускать полные узлы. только достаточно крупным организациям. В результате пользователи не смогут самостоятельно проверять состояние и безнадежно участвовать в сети.

Это оставляет нас с пониманием того, что пропускная способность L1 должна быть ограничена, чтобы поддерживать действительно децентрализованную и безопасную систему.

### Почему те же самые барьеры не влияют на свертку достоверности?

Только при рассмотрении перспективы полного узла мы видим истинную мощь, предлагаемую накопительными пакетами достоверности. Полный узел L1 должен повторно выполнить всю историю, чтобы обеспечить правильность текущего состояния. Узлы Starknet должны только проверять доказательства STARK, и эта проверка требует экспоненциально меньшего количества вычислительных ресурсов. В частности, синхронизация с нуля не требует выполнения; узел может получить дамп текущего состояния от своих одноранговых узлов и только проверить с помощью доказательства STARK, что это состояние действительно. Это позволяет нам увеличить пропускную способность сети без увеличения требований от полного узла.

Поэтому мы заключаем, что секвенсор L2 подвергается целому спектру оптимизаций, которые невозможны на L1.

### Дорожная карта производительности впереди

В следующих разделах мы обсудим, какие из них в настоящее время запланированы для секвенсора Starknet.

### Распараллеливание секвенсора

Первым шагом в нашей дорожной карте было введение параллелизма в выполнение транзакций. Это было представлено в альфа-версии Starknet 0.10.2, которая была выпущена вчера в основной сети. Теперь мы углубимся в то, что такое распараллеливание (это полутехнический раздел, чтобы продолжить дорожную карту, перейдите к следующему разделу).

Так что же означает «распараллеливание транзакций»? Наивно, параллельное выполнение блока транзакций невозможно, так как разные транзакции могут быть зависимыми. Это показано в следующем примере. Рассмотрим блок с тремя транзакциями от одного пользователя:

* Транзакция A: обмен USDC на ETH
* Транзакция B: оплата ETH за NFT
* Транзакция C: обмен USDT на BTC

Ясно, что Tx A должен произойти до Tx B, но Tx C полностью независим от обоих и может выполняться параллельно. Если для выполнения каждой транзакции требуется 1 секунда, то время производства блока можно сократить с 3 до 2 секунд, введя распараллеливание.

Суть проблемы в том, что мы не знаем заранее зависимости транзакций. На практике, только когда мы выполняем транзакцию B из нашего примера, мы видим, что она зависит от изменений, сделанных транзакцией A. Более формально зависимость следует из того факта, что транзакция B читает из ячеек памяти, в которые транзакция A записала. Мы можем думать о транзакциях как о графе зависимостей, где есть ребро от транзакции A к транзакции B, если и только если A записывает в ячейку хранения, которая читается B, и, следовательно, должна быть выполнена до B. На следующем рисунке показана пример такого графа зависимостей:

![](https://lh5.googleusercontent.com/OXpkhtGdVlJsLZ9fkz4bFdTIqkOyvGYDaqP3mz_XZSPmPtqy7uZFwlOIHy8e3E4N4rGEPBj0kBpYTsXfIS7q3WURb6kO7HIIZ9cWHaADaPVZoCTdUEQ-uBDLz8e2so0smCleiJRZyZqVLaDVGX3aiJo)

В приведенном выше примере каждый столбец может выполняться параллельно, и это оптимальное расположение (хотя наивно мы бы выполняли транзакции 1–9 последовательно).

Чтобы преодолеть тот факт, что граф зависимостей заранее не известен, мы вводим оптимистическое распараллеливание в духе [BLOCK-STM](https://malkhi.com/posts/2022/04/block-stm/) , разработанного Aptos Labs, для секвенсора Starknet. В соответствии с этой парадигмой мы оптимистично пытаемся запускать транзакции параллельно и повторно выполнять их при обнаружении коллизии. Например, мы можем параллельно выполнять транзакции 1–4 с рисунка 1, только чтобы потом узнать, что Tx4 зависит от Tx1. Следовательно, его выполнение было бесполезным (мы запускали его относительно того же состояния, против которого мы запускали Tx1, в то время как мы должны были запускать его против состояния, полученного в результате применения Tx1). В этом случае мы повторно выполним Tx4.

Обратите внимание, что мы можем добавить множество оптимизаций поверх оптимистического распараллеливания. Например, вместо того, чтобы наивно ждать завершения каждого выполнения, мы можем прервать выполнение в тот момент, когда находим зависимость, которая делает его недействительным.

Другой пример — оптимизация выбора транзакций для повторного выполнения. Предположим, что блок, состоящий из всех транзакций с рисунка 1, подается в секвенсор с пятью ядрами ЦП. Сначала мы пытаемся выполнить транзакции 1–5 параллельно. Если порядок завершения был Tx2, Tx3, Tx4, Tx1 и, наконец, Tx5, то мы найдем зависимость Tx1→Tx4 только после того, как Tx4 уже был выполнен, что указывает на то, что его следует выполнить повторно. Наивно, мы можем также захотеть повторно выполнить Tx5, так как он может вести себя иначе при новом выполнении Tx4. Однако вместо того, чтобы просто повторно выполнять все транзакции после уже признанного недействительным Tx4, мы можем пройти по графу зависимостей, построенному из транзакций, выполнение которых уже завершено, и повторно выполнить только те транзакции, которые зависели от Tx4.

### Новая реализация Rust для Cairo-VM

Смарт-контракты в Starknet пишутся в Cairo и выполняются внутри Cairo-VM, спецификация которой приведена в документе [Cairo](https://eprint.iacr.org/2021/1063.pdf). В настоящее время секвенсор использует версию [python](https://github.com/starkware-libs/cairo-lang/tree/master/src/starkware/cairo/lang/vm) Cairo-VM. Чтобы оптимизировать производительность реализации ВМ, мы начали работу по переписыванию ВМ на rust. Благодаря отличной работе [Lambdaclass](https://lambdaclass.com/), которые на данный момент являются бесценной командой в экосистеме Starknet, эти усилия скоро принесут свои плоды.

Реализация Rust виртуальной машины, [cairo-rs](https://github.com/lambdaclass/cairo-rs), теперь может выполнять собственный код Cairo. Следующим шагом является обработка выполнения смарт-контрактов и интеграция с секвенсором pythonic. Ожидается, что после интеграции с cairo-rs производительность секвенсора значительно улучшится.

### Повторная реализация секвенсора в Rust

Наш переход с Python на Rust для повышения производительности не ограничивается виртуальной машиной Cairo. Наряду с упомянутыми выше улучшениями, мы планируем переписать секвенсор с нуля в rust. В дополнение к внутренним преимуществам Rust это дает возможность для других оптимизаций секвенсора. Перечислив пару, мы можем пользоваться преимуществами cairo-rs без накладных расходов на связь python-rust, и мы можем полностью изменить способ хранения и доступа к состоянию (который сегодня основан на структуре [Patricia-Trie](https://docs.starknet.io/documentation/develop/State/starknet-state/#state_commitment)).

### А пруверы?

В этом посте мы не упомянули, пожалуй, самый известный элемент сверток достоверности — доказывающий. Можно представить, что, будучи, возможно, самым сложным компонентом архитектуры, он должен быть узким местом и, следовательно, объектом оптимизации. Интересно, что именно более «стандартные» компоненты сейчас являются узким местом Starknet. Сегодня, особенно с [рекурсивных доказательств](https://medium.com/starkware/recursive-starks-78f8dd401025), мы можем уместить в доказательство намного больше транзакций, чем текущий трафик в Testnet/Mainnet. На самом деле, сегодня блоки Starknet доказываются наряду с транзакциями StarkEx, где последние иногда могут иметь несколько сотен тысяч монетных дворов NFT.

### Краткое содержание

Распараллеливание, Rust и многое другое — приготовьтесь к улучшенному TPS в будущих версиях Starknet.