### TL;DR

* Роллы действительности не ограничиваются пропускной способностью таким же образом, как L1. Это приводит к потенциально гораздо более высоким TPS на валидациях качества L2.
* Карта эффективности StarkNet адресована ключевому элементу в системе: последовательности.
* Мы представляем здесь план повышения эффективности:\
  — параллелизация последовательности\
  — новая реализация ржавчины для Каирской VM\
  — реализация последовательности на ржавчи\
* Проверок, испытанных на бою, не являются узкими местами и могут справиться гораздо больше, чем сейчас!

### Введение

StarkNet запущен на Mainnet почти год назад. Мы начали строить StarkNet, сосредоточив внимание на функциональности. Теперь мы переориентируемся на улучшение производительности с рядом шагов, которые помогут улучшить опыт StarkNet.

В этом посте мы объясняем, почему существует широкий спектр оптимизаций, которые применимы только в ротациях действительности, и мы будем делиться нашим планом по реализации этих шагов в StarkNet. Некоторые из этих шагов уже реализованы в Alpha 0.10.2, который был выпущен на Testnet 16 и вчера в Mainnet. Но прежде чем мы обсудим решения, давайте рассмотрим ограничения и их причины.

### Ограничения блока: откаты по действию против L1

Потенциальным подходом к увеличению масштабируемости блокчейна и увеличению TPS было бы устранение ограничений блоков (в плане газа/размера) при сохранении постоянного времени блоков. Для этого потребуется больше усилий со стороны производителей блоков (валидаторы L1, Последователи на L2) и таким образом призывают к более эффективному осуществлению этих компонентов. С этой целью мы переместим фокус на оптимизацию последовательности StarkNet, который более подробно описывается в следующих разделах.

Здесь возникает естественный вопрос. Почему оптимизация последовательности ограничивается откатами действительности, то есть Почему мы не можем реализовать те же улучшения на L1 и полностью избежать сложности прокрутки действия? В следующем разделе мы утверждаем, что между этими двумя элементами существует принципиальная разница, позволяет использовать широкий диапазон оптимизации на L2, которые не применимы к L1.

### Почему пропускная способность L1 ограничена?

К сожалению, снятие ограничений на блоки L1 страдает от серьезного подлова. Повышая темпы роста цепи, мы также увеличиваем спрос со стороны полных узлов, которые пытаются сохранить последнее состояние. Поскольку полные узлы L1 должны повторно выполнить всю историю, - значительное увеличение размера блока (по газам) оказывает на них существенный напряжение; снова приводит к ослаблению машин, выбрасываемых из системы и оставляя возможность запускать полные узлы только достаточно крупным. В результате пользователи не смогут самостоятельно проверить состояние и бесправно участвовать в сети.

Это оставляет нам понимание того, что осуществление проекта L1 должно быть ограниченным, с тем чтобы сохранить подлинно децентрализованную и безопасную систему.

### Почему не одни и те же барьеры влияют на валидацию действия?

**Только при рассмотрении перспектив полного узла мы видим истинную мощность, предлагаемую при выравнивании достоверности.**Чтобы убедиться в правильности текущего состояния, полному узлу L1 необходимо повторно выполнить всю историю. StarkNet нуждается в проверке только доказательств STARK, и эта проверка занимает экспоненциально меньшее количество вычислительных ресурсов. В частности, синхронизация с нуля не требует казни; узел может получить дамп текущего состояния от его соседей и проверить только доказательство того, что данное состояние является действительным. Это позволяет нам увеличивать пропускную способность сети без увеличения требований с полного узла.

Поэтому мы делаем вывод о том, что последовательность L2 подвержена всему спектру оптимизаций, которые не возможны на L1.

### Карта эффективности впереди

В следующих разделах мы обсудим, какие из них в настоящее время запланированы для StarkNet последовательности.

### Выравнивание последовательности

Первым шагом на нашей дорожной карте было внедрение параллеливания с исполнением сделки. Это было представлено в StarkNet альфа 0.10.2, который был выпущен вчера на Майнете. Сейчас мы погружаемся в то, что является параллелизацией (это полутехнический раздел, чтобы продолжить работу по «дорожной карте», переход к следующему разделу).

Итак, что означает "распараллеливание" сделки? Напротив, выполнение блока транзакций параллельно невозможно, поскольку разные транзакции могут быть зависимыми. Это иллюстрируется в следующем примере. Рассмотрим блок с тремя транзакциями одного пользователя:

* Транзакция A: замена USDC на ETH
* Транзакция B: оплата ETH за NFT
* Транзакция C: обмен USDT для BTC

Понятно, что Tx A должен происходить до Tx B, но Tx C полностью независима от обеих и может выполняться параллельно. Если для каждой транзакции требуется 1 секунду, то время производства блоков может быть сокращено с 3 секунд до 2 секунд, введя параллелизацию.

Суть проблемы заключается в том, что мы не знаем зависимостей сделки заранее. На практике только тогда, когда мы выполняем транзакцию В из нашего примера, мы видим, что она основывается на изменениях транзакции А. В более формальном плане зависимость зависит от того факта, что транзакция В читает от камер хранения, в которые написана транзакция А. Мы можем думать о транзакциях как о графике зависимостей, где есть край от транзакции A к транзакции B iff A записывает в камеру хранения, которую читает B, и таким образом должны быть выполнены до B. На следующем рисунке показан пример графика зависимостей:

![](https://miro.medium.com/max/641/0*I-qGgxdJJmqmgZWM)

В приведенном выше примере каждая колонка может выполняться параллельно, и это оптимальная договоренность (хотя и наивно, мы бы выполнили транзакции 1–9 последовательно).

Чтобы преодолеть тот факт, что график зависимостей не известен заранее, мы вводим***оптимистическую распараллеливание***, в духе[BLOCK-STM](https://malkhi.com/posts/2022/04/block-stm/)разработанного Aptos Labs, к последовательности StarkNet. В соответствии с этой парадигмой мы с оптимизмом пытаемся параллельно запускать транзакции и повторять их при нахождении столкновения. Например, мы можем выполнять транзакции 1–4 из рисунка 1 параллельно, только потом выяснить, что Tx4 зависит от Tx1. Следовательно, его исполнение было бесполезным (мы запустили его относительно того же состояния, которое мы запускали Tx1, против в то время как мы должны были запустить его против состояния в результате применения Tx1). В этом случае мы перезапустим Tx4.

Обратите внимание, что мы можем добавить много оптимизаций поверх оптимистического распараллеливания. Например, а не наивное ожидание завершения каждого выполнения, мы можем прервать выполнение после того, как мы найдем зависимость, которая лишает его.

Другим примером является оптимизация выбора транзакций для повторного выполнения. Предположим, что блок, состоящий из всех транзакций из рисунка 1, подается в последовательность с пятью ядрами процессора. Во-первых, мы пытаемся выполнить транзакции 1–5 параллельно. Если порядок выполнения был Tx2, Tx3, Tx4, Tx1, и, наконец, Tx5, , то мы найдем зависимость Tx1→Tx4 только после того, как Tx4 был запущен — это означает, что она должна быть выполнена. Наконец-то мы можем захотеть повторно запустить Tx5, так как он может вести себя по-разному с новым запуском Tx4. Однако, вместо того, чтобы просто повторить все транзакции после того, как был признан недействительным Tx4, мы можем повернуть граф зависимостей, построенный из транзакций, выполнение которых уже завершилось, и только повторное выполнение транзакций, зависящих от Tx4.

### Новый проект "Русь" для Каира-ВМ

Умные контракты в StarkNet написаны в Каире и выполняются внутри Cairo-VM, которая указывается в[Каирской бумаге](https://eprint.iacr.org/2021/1063.pdf). В настоящее время sequencer использует[python реализацию](https://github.com/starkware-libs/cairo-lang/tree/master/src/starkware/cairo/lang/vm)из Cairo-VM. Для оптимизации производительности реализации ВМ мы приложили усилия по переписыванию ВМ в оперативном режиме. Благодаря большой работе[Lambdaclass](https://lambdaclass.com/), которые к настоящему времени бесценная команда в экосистеме StarkNet, эти усилия вскоре приходят к плоду.

Ржавая реализация VM,[cairo-rs](https://github.com/lambdaclass/cairo-rs), теперь может выполнить родной код Каира. Следующим шагом является обработка смарт-контрактов исполнения и интеграции с питонической последовательностью. После интеграции с кейро производительность последовательности будет значительно улучшаться.

### Реализация последовательности в Rust

Наш переход от python к rust к повышению производительности не ограничивается Cairo VM. Помимо улучшений, упомянутых выше, мы планируем переписать последовательность с нуля в ржавчину. Помимо внутренних преимуществ Руси, это дает возможность другим оптимизациям в последовательности. Перечисляя пару, мы можем наслаждаться преимуществами кайронов без накладки питона-ржавчины, и мы можем полностью изменить способ хранения и доступа к состоянию (который основан на[структуре Patricia-Trie](https://docs.starknet.io/documentation/develop/State/starknet-state/#state_commitment)).

### Как насчет прокрутки?

На протяжении всего этого поста мы не упомянули о наиболее известном элементе валидаций — ровере. Можно представить себе, что являясь наиболее сложным компонентом архитектуры, он должен быть узким местом и, таким образом, фокусом оптимизации. Интересно, что более «стандартными» компонентами, которые сейчас являются узким местом StarkNet. Сегодня, особенно с[рекурсивных доказательств](https://medium.com/starkware/recursive-starks-78f8dd401025), мы можем вместить намного больше транзакций, чем текущий трафик на Testnet/Mainnet в доказательстве. На самом деле, сегодня блоки StarkNet доказаны наряду со StarkEx, где последние иногда могут повлечь несколько сотен тысяч NFT мин.

### Summary

Параллелизация, Рассел и многое другое — скобки для улучшения TPS в предстоящих версиях StarkNet.