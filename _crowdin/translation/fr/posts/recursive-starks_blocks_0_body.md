### TL;DR

* La preuve rÃ©cursive est en direct sur Mainnet, mettant Ã  l'Ã©chelle les applications StarkEx ainsi que StarkNet avec une seule preuve
* Il augmente l'Ã©chelle et offre des avantages en termes de coÃ»t et de latence (un Ã©vÃ©nement rare et passionnant oÃ¹ l'Ã©chelle et la latence Ã©voluent en tandem et ne constituent pas un compromis)
* Il prÃ©pare le terrain pour L3 et d'autres avantages. Allez lire le billet de blog sur[Recursive Proving](https://medium.com/@starkware/recursive-starks-78f8dd401025). C'est cool ğŸ˜‰

### Mise Ã  l'Ã©chelleÂ !

Des preuves rÃ©cursives - alimentÃ©es par le calcul gÃ©nÃ©ral de Cairo - sont maintenant en production. Cela marque une augmentation majeure de la puissance de la mise Ã  l'Ã©chelle L2 avec les STARK. Il fournira rapidement une augmentation multiple du nombre de transactions pouvant Ãªtre Ã©crites sur Ethereum via une seule preuve.

Jusqu'Ã  prÃ©sent, la mise Ã  l'Ã©chelle de STARK fonctionnait en Â«regroupantÂ» des dizaines, voire des centaines de milliers de transactions en une seule preuve, qui Ã©tait Ã©crite sur Ethereum. Avec la rÃ©cursivitÃ©, de nombreuses preuves de ce type peuvent Ãªtre Â«Â regroupÃ©esÂ Â» en une seule preuve.

Cette mÃ©thode est dÃ©sormais en production pour une multitude d'applications basÃ©es sur CairoÂ : des applications exÃ©cutÃ©es sur StarkEx, le moteur de mise Ã  l'Ã©chelle SaaS de StarkWare, et StarkNet, le cumul sans autorisation.

### L'histoire jusqu'ici

Depuis la premiÃ¨re preuve sur Mainnet, en mars 2020, les dÃ©veloppements suivants ont faÃ§onnÃ© la faÃ§on dont les STARK sont utilisÃ©s.

### Mise Ã  l'Ã©chelle basÃ©e sur STARK

En juin 2020, la premiÃ¨re solution de mise Ã  l'Ã©chelle basÃ©e sur STARK -[StarkEx](https://youtu.be/P-qoPVoneQA)- a Ã©tÃ© dÃ©ployÃ©e sur Ethereum Mainnet. StarkEx a un prouveur qui effectue de gros calculs hors chaÃ®ne et produit une preuve STARK pour leur exactitude, et un vÃ©rificateur qui vÃ©rifie cette preuve en chaÃ®ne. Les contraintes pour ce premier dÃ©ploiement ont Ã©tÃ© "Ã©crites Ã  la main" par les ingÃ©nieurs de StarkWare, limitant ainsi considÃ©rablement la vitesse des fonctionnalitÃ©s pour StarkEx. Nous avons conclu qu'un langage de programmation pour prendre en charge la preuve du calcul gÃ©nÃ©ral est nÃ©cessaire - Cairo.

#### Cairo

Ã€ l'Ã©tÃ© 2020, Le Caire a fait sa[premiÃ¨re apparition sur Ethereum Mainnet](https://medium.com/starkware/hello-cairo-3cb43b13b209). Cairo signifie CPU Algebraic Intermediate Representation (AIR), et comprend un seul AIR qui vÃ©rifie le jeu d'instructions de ce "CPU". Cela a ouvert la porte au codage de preuves pour une logique mÃ©tier plus complexe, pour des dÃ©clarations de calcul arbitraires, et pour le faire de maniÃ¨re plus rapide et plus sÃ»re. Un programme Cairo peut prouver l'exÃ©cution de la logique d'une seule application. Mais un programme Cairo peut Ã©galement Ãªtre une concatÃ©nation de plusieurs applications de ce type - SHARP.

#### POINTU

SHARP - un SHARed Prover - prend les transactions de plusieurs applications distinctes et les prouve toutes dans une seule Ã©preuve STARK. Les applications combinent leurs lots de transactions, remplissant plus rapidement la capacitÃ© d'un test STARK. Les transactions sont traitÃ©es Ã  un rythme et une latence amÃ©liorÃ©s. La prochaine frontiÃ¨re : les preuves rÃ©cursives, mais pas seulement pour une logique codÃ©e en dur, mais plutÃ´t pour**calcul gÃ©nÃ©ral**.

Pour comprendre tous les avantages de la preuve rÃ©cursive, il est utile de comprendre un peu plus comment la preuve (non rÃ©cursive) Ã©tait effectuÃ©e par SHARP jusqu'Ã  prÃ©sent. Le dessin 1 illustre un flux non rÃ©cursif typiqueÂ :

![Dessin 1Â : Un flux de preuve non rÃ©cursif typique](/assets/recursive_starks_01.png "Dessin 1Â : Un flux de preuve non rÃ©cursif typique")

Ici, les dÃ©clarations arrivent au fil du temps. Lorsqu'un certain seuil de capacitÃ© (ou de temps) est atteint, une grande dÃ©claration combinÃ©e (alias Train) est gÃ©nÃ©rÃ©e. Cette dÃ©claration combinÃ©e n'est prouvÃ©e qu'une fois que toutes les dÃ©clarations individuelles ont Ã©tÃ© reÃ§ues. Cette preuve prend beaucoup de temps Ã  prouver (environ la somme de temps qu'il faut pour prouver chaque dÃ©claration individuellement).

La preuve d'instructions extrÃªmement volumineuses est finalement limitÃ©e par les ressources de calcul disponibles telles que la mÃ©moire. Avant la rÃ©cursivitÃ©, c'Ã©tait effectivement la barriÃ¨re limitant l'Ã©volutivitÃ© de la preuve STARK.

### Qu'est-ce que la preuve rÃ©cursiveÂ ?

Avec les preuves STARK, le temps nÃ©cessaire pour prouver une dÃ©claration est Ã  peu prÃ¨s linÃ©aire avec le temps nÃ©cessaire pour exÃ©cuter la dÃ©claration. De plus, si prouver une dÃ©claration prend un temps T, alors la vÃ©rification de la preuve prend environ un temps log(T), ce qui est gÃ©nÃ©ralement appelÃ© Â«Â compression logarithmiqueÂ Â». En d'autres termes, avec les STARK, vous passez beaucoup moins de temps Ã  vÃ©rifier le relevÃ© qu'Ã  le calculer.

[Cairo](https://starkware.co/cairo/)permet d'exprimer des dÃ©clarations informatiques gÃ©nÃ©rales qui peuvent Ãªtre prouvÃ©es par des preuves STARK et vÃ©rifiÃ©es par les vÃ©rificateurs STARK correspondants.

C'est lÃ  que l'opportunitÃ© d'effectuer[rÃ©cursivitÃ©](https://en.wikipedia.org/wiki/Recursion)entre en jeuÂ : de la mÃªme maniÃ¨re que nous Ã©crivons un programme Cairo qui prouve l'exactitude de milliers de transactions, nous pouvons Ã©galement Ã©crire un programme Cairo qui vÃ©rifie plusieurs preuves STARK. Nous pouvons gÃ©nÃ©rer une preuve unique attestant de la validitÃ© de multiples preuves Â« en amont Â». C'est ce que nous appelons la preuve rÃ©cursive.

En raison de la compression logarithmique et du temps de preuve Ã  peu prÃ¨s linÃ©aire, prouver une vÃ©rification d'une preuve STARK prend un temps relativement court (qui ne devrait Ãªtre que de quelques minutes dans un proche avenir).

Lors de la mise en Å“uvre de la rÃ©cursivitÃ©, SHARP peut prouver les dÃ©clarations Ã  leur arrivÃ©e. Leurs preuves peuvent Ãªtre fusionnÃ©es encore et encore en preuves rÃ©cursives dans divers modÃ¨les jusqu'Ã  ce que, Ã  un certain moment, la preuve rÃ©sultante soit soumise Ã  un contrat de vÃ©rificateur en chaÃ®ne. Un modÃ¨le typique est illustrÃ© dans le dessin 2Â :

![Dessin 2 : Un flux de preuve rÃ©cursif typique.](/assets/recursive_starks_02.png "Dessin 2 : Un flux de preuve rÃ©cursif typique.")

### Avantages immÃ©diats de la preuve rÃ©cursive

#### RÃ©duction des coÃ»ts en chaÃ®ne

DÃ¨s le dÃ©part, nous obtenons la Â«compressionÂ» de plusieurs preuves en une seule, ce qui implique un coÃ»t de vÃ©rification en chaÃ®ne infÃ©rieur par transaction (oÃ¹ chaque dÃ©claration peut inclure de nombreuses transactions).

Avec la rÃ©cursivitÃ©, la barriÃ¨re des ressources de calcul (par exemple la mÃ©moire) qui limitait la taille des preuves jusqu'Ã  prÃ©sent, est Ã©liminÃ©e, puisque chaque instruction de taille limitÃ©e peut Ãªtre prouvÃ©e sÃ©parÃ©ment. Par consÃ©quent, lors de l'utilisation de la rÃ©cursivitÃ©, la taille effective du train de rÃ©cursivitÃ© est presque illimitÃ©e et le coÃ»t par transaction peut Ãªtre rÃ©duit de plusieurs ordres de grandeur.

ConcrÃ¨tement, la rÃ©duction dÃ©pend de la latence acceptable (et du rythme d'arrivÃ©e des transactions). De plus, Ã©tant donnÃ© que chaque preuve est gÃ©nÃ©ralement accompagnÃ©e de certaines sorties telles que des donnÃ©es en chaÃ®ne, il y a des limites Ã  la quantitÃ© de donnÃ©es qui peuvent Ãªtre Ã©crites en chaÃ®ne avec une seule preuve. NÃ©anmoins, rÃ©duire les coÃ»ts d'un ordre de grandeur et mÃªme mieux est tout Ã  fait rÃ©alisable.

#### Latence rÃ©duite

Le modÃ¨le de preuve rÃ©cursive rÃ©duit la latence de la preuve de grands trains d'instructions. Ceci est le rÃ©sultat de deux facteurs :

1. Les dÃ©clarations entrantes peuvent Ãªtre prouvÃ©es**en parallÃ¨le**(par opposition Ã  la preuve d'une dÃ©claration combinÃ©e extrÃªmement grande).
2. Il n'est pas nÃ©cessaire d'attendre que la derniÃ¨re dÃ©claration du train arrive pour commencer Ã  prouver. Au contraire, les preuves peuvent Ãªtre combinÃ©es avec de nouvelles dÃ©clarations Ã  mesure qu'elles arrivent. Cela signifie que la latence de la derniÃ¨re dÃ©claration rejoignant un train correspond Ã  peu prÃ¨s au temps nÃ©cessaire pour prouver cette toute derniÃ¨re dÃ©claration plus le temps nÃ©cessaire pour prouver une dÃ©claration de vÃ©rificateur rÃ©cursif (qui atteste de toutes les dÃ©clarations qui ont dÃ©jÃ  "intÃ©grÃ©" ce train particulier).

Nous dÃ©veloppons et optimisons activement la latence de la preuve de l'instruction Recursive Verifier. Nous nous attendons Ã  ce que cela atteigne l'ordre de quelques minutes d'ici quelques mois. Par consÃ©quent, un SHARP trÃ¨s efficace peut offrir des latences allant de quelques minutes Ã  quelques heures, en fonction du compromis par rapport au coÃ»t en chaÃ®ne par transaction. Cela reprÃ©sente une amÃ©lioration significative de la latence de SHARP.

#### Faciliter L3

Le dÃ©veloppement de la dÃ©claration Recursive Verifier au Caire ouvre Ã©galement la possibilitÃ© de soumettre des preuves Ã  StarkNet, car cette dÃ©claration peut Ãªtre intÃ©grÃ©e dans un contrat intelligent StarkNet. Cela permet de construire[dÃ©ploiements L3 au-dessus du StarkNet](https://medium.com/starkware/fractal-scaling-from-l2-to-l3-7fe238ecfb4f)public (un rÃ©seau L2).

Le schÃ©ma rÃ©cursif s'applique Ã©galement Ã  l'agrÃ©gation des preuves de L3, Ã  vÃ©rifier par une seule preuve sur L2. Par consÃ©quent, l'hyper-scalabilitÃ© y est Ã©galement rÃ©alisÃ©e.

### Avantages plus subtils

#### RÃ©cursivitÃ© applicative

La rÃ©cursivitÃ© ouvre encore plus d'opportunitÃ©s pour les plates-formes et les applications souhaitant augmenter davantage leurs coÃ»ts et leurs performances.

Chaque preuve STARK atteste de la validitÃ© d'un Ã©noncÃ© appliquÃ© Ã  une entrÃ©e appelÃ©e Â«entrÃ©e publiqueÂ» (ou Â«sortie de programmeÂ» en termes du Caire). Conceptuellement, la rÃ©cursivitÃ© STARK comprime deux preuves avec*deux*entrÃ©es en*une*preuves avec deux entrÃ©es. En d'autres termes, alors que le nombre de preuves est rÃ©duit, le nombre d'entrÃ©es est maintenu constant. Ces entrÃ©es sont alors gÃ©nÃ©ralement utilisÃ©es par une application afin de mettre Ã  jour un Ã©tat sur L1 (par exemple pour mettre Ã  jour une racine d'Ã©tat ou effectuer un retrait en chaÃ®ne).

Si l'instruction rÃ©cursive est autorisÃ©e Ã  Ãªtre*sensible Ã  l'application*, c'est-Ã -dire qu'elle reconnaÃ®t la sÃ©mantique de l'application elle-mÃªme, elle peut Ã  la fois compresser deux preuves en une seule*et*combiner les deux entrÃ©es en une seule. L'instruction rÃ©sultante atteste de la validitÃ© de la combinaison d'entrÃ©e basÃ©e sur la sÃ©mantique de l'application, d'oÃ¹ le nom Applicative Recursion (voir Dessin 3, pour un exemple).

![Dessin 3Â : Exemple de rÃ©cursivitÃ© applicative](/assets/recursive_starks_03.png "Dessin 3Â : Exemple de rÃ©cursivitÃ© applicative")

Ici, la dÃ©claration 1 atteste d'une mise Ã  jour de l'Ã©tat de A Ã  B et la dÃ©claration 2 atteste d'une nouvelle mise Ã  jour de B Ã  C. Les preuves de la dÃ©claration 1 et de la dÃ©claration 2 peuvent Ãªtre combinÃ©es dans une troisiÃ¨me dÃ©claration, attestant de la mise Ã  jour directe de A Ã  C. En appliquant une logique similaire de maniÃ¨re rÃ©cursive, on peut rÃ©duire le coÃ»t des mises Ã  jour d'Ã©tat de maniÃ¨re trÃ¨s significative jusqu'Ã  l'exigence de latence de finalitÃ©.

Un autre exemple important de rÃ©cursivitÃ© applicative consiste Ã  compresser les donnÃ©es cumulÃ©es de plusieurs preuves. Par exemple, pour un cumul de validitÃ© tel que StarkNet, chaque mise Ã  jour de stockage sur L2 est Ã©galement incluse en tant que donnÃ©es de transmission sur L1, pour garantir la disponibilitÃ© des donnÃ©es. Cependant, il n'est pas nÃ©cessaire d'envoyer plusieurs mises Ã  jour pour le mÃªme Ã©lÃ©ment de stockage, car seule la valeur finale des transactions attestÃ©e par la preuve vÃ©rifiÃ©e est requise pour la disponibilitÃ© des donnÃ©es. Cette optimisation est dÃ©jÃ  effectuÃ©e dans un bloc*unique*StarkNet. Cependant, en gÃ©nÃ©rant une preuve par bloc, Applicative Recursion peut compresser ces donnÃ©es de cumul sur*multiples*blocs L2. Cela peut entraÃ®ner une rÃ©duction significative des coÃ»ts, permettant des intervalles de bloc plus courts sur L2, sans sacrifier l'Ã©volutivitÃ© des mises Ã  jour L1.

Ã€ noterÂ : la rÃ©cursivitÃ© applicative peut Ãªtre combinÃ©e avec la rÃ©cursivitÃ© indÃ©pendante de l'application, comme illustrÃ© prÃ©cÃ©demment. Ces deux optimisations sont indÃ©pendantes.

#### ComplexitÃ© rÃ©duite du vÃ©rificateur en chaÃ®ne

La complexitÃ© du vÃ©rificateur STARK dÃ©pend du type d'instructions qu'il est conÃ§u pour vÃ©rifier. En particulier, pour les instructions Cairo, la complexitÃ© du vÃ©rificateur dÃ©pend des Ã©lÃ©ments spÃ©cifiques autorisÃ©s dans le langage Cairo et, plus prÃ©cisÃ©ment, des Ã©lÃ©ments intÃ©grÃ©s pris en charge (si nous utilisons la mÃ©taphore CPU pour Cairo, les Ã©lÃ©ments intÃ©grÃ©s sont l'Ã©quivalent de micro -circuits dans un CPU : calculs effectuÃ©s si frÃ©quemment qu'ils nÃ©cessitent leur propre calcul optimisÃ©).

Le langage Cairo continue d'Ã©voluer et offre de plus en plus d'Ã©lÃ©ments intÃ©grÃ©s utiles. D'autre part, le vÃ©rificateur rÃ©cursif ne nÃ©cessite l'utilisation que d'un petit sous-ensemble de ces Ã©lÃ©ments intÃ©grÃ©s. Par consÃ©quent, un SHARP rÃ©cursif peut prendre en charge avec succÃ¨s n'importe quelle instruction du Caire en prenant en charge le langage complet dans les vÃ©rificateurs rÃ©cursifs. Plus prÃ©cisÃ©ment, le vÃ©rificateur de soliditÃ© L1 n'a besoin que de vÃ©rifier les preuves rÃ©cursives et peut donc Ãªtre limitÃ© Ã  un sous-ensemble plus stable du langage du CaireÂ : le vÃ©rificateur L1 n'a pas besoin de suivre les derniÃ¨res et les meilleures fonctionnalitÃ©s intÃ©grÃ©es. En d'autres termes, la vÃ©rification des dÃ©clarations complexes en constante Ã©volution est relÃ©guÃ©e Ã  L2, laissant le vÃ©rificateur L1 vÃ©rifier des dÃ©clarations plus simples et plus stables.

#### Empreinte de calcul rÃ©duite

Avant la rÃ©cursivitÃ©, la capacitÃ© d'agrÃ©ger plusieurs dÃ©clarations en une seule preuve Ã©tait limitÃ©e par la taille maximale de la dÃ©claration qui pouvait Ãªtre prouvÃ©e sur les instances de calcul disponibles (et le temps qu'il fallait pour gÃ©nÃ©rer de telles preuves).

Avec la rÃ©cursivitÃ©, il n'est plus nÃ©cessaire de prouver de telles dÃ©clarations extrÃªmement volumineuses. En consÃ©quence, des instances de calcul plus petites, moins chÃ¨res et plus disponibles peuvent Ãªtre utilisÃ©es (bien qu'un plus grand nombre d'entre elles puisse Ãªtre nÃ©cessaire qu'avec de grands prouveurs monolithiques). Cela permet le dÃ©ploiement d'instances de preuve dans plus d'environnements physiques et virtuels qu'auparavant.

### RÃ©sumÃ©

Les preuves rÃ©cursives de calcul gÃ©nÃ©ral servent dÃ©sormais plusieurs systÃ¨mes de production, y compris StarkNet, sur Mainnet Ethereum.

Les avantages de la rÃ©cursivitÃ© se concrÃ©tiseront progressivement, car elle continue de permettre de nouvelles amÃ©liorations, et elle offrira bientÃ´t une hyper-Ã©chelle, rÃ©duira les frais de gaz et amÃ©liorera la latence en libÃ©rant le potentiel de la parallÃ©lisation.

Il apportera des avantages significatifs en termes de coÃ»t et de latence, ainsi que de nouvelles opportunitÃ©s telles que L3 et la rÃ©cursivitÃ© applicative. Une optimisation plus poussÃ©e du vÃ©rificateur rÃ©cursif est en cours et des performances et des coÃ»ts encore meilleurs devraient Ãªtre fournis au fil du temps.



**Gidi Kaempfer**, responsable de l'ingÃ©nierie centrale, StarkWare