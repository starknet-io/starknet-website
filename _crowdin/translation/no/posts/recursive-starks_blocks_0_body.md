### TL;DR

* Rekursivt funn er live pÃ¥ Mainnet, skalering av StarkEx applikasjoner, i tillegg til StarkNet med ett enkelt bevis
* Det Ã¸ker omfanget og gir kostnadsmessig nytte og latens (en sjelden og spennende forekomst av skala og latens som beveger seg i telandem, og ikke er omsettelig)
* Den angir stadiet for L3 og andre fordeler. GÃ¥ og les blogginnlegget pÃ¥[Gjentakende bekreftelse](https://medium.com/@starkware/recursive-starks-78f8dd401025). Det er kule ting ğŸ˜‰

### Skalering opp!

Refeldige bekreftelser â€“ drevet av denne generelle databeregningen â€“ er nÃ¥ i produksjon. Dette er et viktig lÃ¸ft for L2-skaleringens styrke med STARKs. Den vil raskt levere en flerfoldig Ã¸kning i antallet transaksjoner som kan skrives til Ethereum via ett bevis.

Fram til nÃ¥ har STARK skalering arbeidet med "rullende opp" titusenvis av transaksjoner i Ã©n enkelt prÃ¸ve, eller til og med hundretalls enkeltprÃ¸ve. som er skrevet til Ethereum. Ved rekursjon kan mange slike lydhoder "rulles opp" inn i ett enkelt bevis.

Metoden gÃ¥r nÃ¥ i produksjon for en mengde Cairo-baserte anvendelser: apps som kjÃ¸rer pÃ¥ StarkEx, StarkWareâ€™s SaaS skaleringsmotor, og StarkNet, den permisjonlÃ¸se rulleringen.

### Historien sÃ¥ langt

Siden det fÃ¸rste beviset pÃ¥ Mainnet i mars 2020 har utviklingen formet hvordan bruk av STARKer.

### STARK-basert skalering

I juni 2020 ble den fÃ¸rste STARK-baserte skaleringslÃ¸sningen â€”[StarkEx](https://youtu.be/P-qoPVoneQA)distribuert pÃ¥ Ethereum Mainnet. StarkEx har en netthotell som utfÃ¸rer store dataoverfÃ¸ringer uten kjede og produserer et STARK-bevis for sin riktighet og en Verifisering som bekrefter denne bekreftelsen pÃ¥ kjeden. Kryptene for denne fÃ¸rste utplasseringen var dermed Â«hÃ¥ndskrevetÂ» av StarkWares ingeniÃ¸rer, og det var dermed sterkt begrensende funksjonshastighet for StarkEx. Vi konkluderte med at et programmeringssprÃ¥k som stÃ¸tter Ã¥ pÃ¥vise generell beregning er nÃ¸dvendig â€“ Kairo.

#### Cairo

Sommeren 2020 gjorde sitt[fÃ¸rste utseende pÃ¥ Ethereum Mainnet](https://medium.com/starkware/hello-cairo-3cb43b13b209). Cairo stÃ¥r for CPU Algebraic Intermediate Representation (AIR), og inkluderer en enkelt AIR som verifiserer instruksjonssettet til dette Â«CPUÂ». Selskapet Ã¥pnet dÃ¸r for kodebevis for mer komplisert forretningsmessig logikk, for vilkÃ¥rlige beregningsuttalelser, og for Ã¥ gjÃ¸re det pÃ¥ en raskere og tryggere mÃ¥te. Et Cairo program vil kunne bevise utfÃ¸relsen av sÃ¸knadens logikk. Men et Cairo program kan ogsÃ¥ vÃ¦re en sammenblanding av flere slike sÃ¸knader â€“ SHARP.

#### DEL

SHARP â€“ en SHARed Prover â€“ tar transaksjoner fra flere separate apper og beviser dem alle i ett enkelt STARK-bevis. Apper kombinerer sine satser pÃ¥ transaksjoner, fyller opp kapasiteten til en STARK-prool raskere. Transaksjonene behandles med bedret rate og forsinkelse. Neste forsider: rekursive alternativer, men ikke bare for noen hardkodet logikk, men snarere for**generell beregning**.

For Ã¥ forstÃ¥ den fulle nytten av rekursiv pÃ¥visning er det verdt Ã¥ forstÃ¥ litt mer om hvordan (ikke kursiv) forsÃ¸k ble utfÃ¸rt ved SHARP inntil nÃ¥. Tegning 1 viser en typisk ikke-rekursiv flyt:

![Tegning 1: En typisk ikke-rekursiv flyt](/assets/recursive_starks_01.png "Tegning 1: En typisk ikke-rekursiv flyt")

Her kommer utsagn over tid. NÃ¥r en bestemt terskel (eller tid) nÃ¥s, genereres det en stor kombinert erklÃ¦ring (Cr.k.a Train). Denne samlede erklÃ¦ringen bevises bare nÃ¥r alle de enkelte erklÃ¦ringene er mottatt. BevisstgjÃ¸ringen tar lang tid (omtrent den tiden det tar Ã¥ dokumentere hver enkelt utsagn.

Det Ã¥ sÃ¸rge for ekstremt store utsagn er eventuelt begrenset av tilgjengelige beregningsressurser, for eksempel hukommelse. FÃ¸r tilbakefall var dette effektivt den begrensende skalabarrieren for STARK-manifestasjonen.

### Hva skjer med rekursiv rekruttering?

NÃ¥r lagene inneholder STARK, er tiden det tar Ã¥ dokumentere erklÃ¦ringen grovt lineÃ¦rt sÃ¥ lang tid den tar Ã¥ gjennomfÃ¸re pÃ¥standen. I tillegg, hvis en projeksjon av erklÃ¦ringen tar T-tid, sÃ¥ verifiseres at beviset tar tilnÃ¦rmet log tid (T), som typisk kalles "logaritmisk trykk". Med andre ord, med STARKer bruker du mye mindre tid pÃ¥ Ã¥ verifisere erklÃ¦ringen enn Ã¥ beregne den.

[Cairo](https://starkware.co/cairo/)tillater Ã¥ uttrykke generelle beregningsanvisninger som kan bevises av STARK-demonstrasjoner og verifiseres av de tilsvarende STARK-verifiserere.

Her er muligheten til Ã¥ utfÃ¸re[rekursjon](https://en.wikipedia.org/wiki/Recursion)vist i: pÃ¥ samme mÃ¥te som vi skriver et Kairo-program som viser at det er riktig med tusenvis av transaksjoner, vi kan ogsÃ¥ skrive et Cairo program som bekrefter flere STARK-bevis. Vi kan generere en enkel dokumentasjon som handler om gyldigheten av flere "opp-stream"-bevis. Det er dette vi kaller rekursiv behandling.

PÃ¥ grunn av logaritmisk kompresjon og grov lineÃ¦r projeksjonstid. det tar relativt kort tid (forventet Ã¥ vÃ¦re noen fÃ¥ minutter i nÃ¦r fremtid Ã¥ verifisere et STARK-bevis).

Ved gjennomfÃ¸ring av gjentagende aktivitet, kan SHARP bevise utsagn nÃ¥r de blir ankomst. Deres lamper kan flettes sammen pÃ¥ nytt og igjen i rekursive bevis i forskjellige mÃ¸nstre, pÃ¥ et visst tidspunkt vil den resulterende beviset gjennomgÃ¥ en verifikasjonskontrakt i kjettingen. Et typisk mÃ¸nster er avbildet under tegning 2:

![Tegning 2: En typisk rekursiv gjennomstrÃ¸mning.](/assets/recursive_starks_02.png "Tegning 2: En typisk rekursiv gjennomstrÃ¸mning.")

### Umiddelbare fordeler ved rekursiv anskaffelse

#### Redusert kostnader

Ved batet fÃ¥r vi "kompresjon" med flere prober til Ã©n, som innebÃ¦rer lavere kostnader for verifikasjon av elektroniske kontroller per transaksjon (der hver erklÃ¦ring kan omfatte mange transaksjoner).

Ved rekursjon barriere mot beregnede ressurser (f.eks. Minne) at et begrenset antall bevis fram til nÃ¥ elimineres, siden hver begrensede stÃ¸rrelsesbestemmelse kan pÃ¥vises separat. Ved rekursjon er derfor den effektive TrainstÃ¸rrelsen nesten ubegrenset, og kostnaden per transaksjon kan reduseres pÃ¥ grunn av ordre.

I praksis avhenger reduksjonen av akseptabel forsinkelse (og raten pÃ¥ hvilke transaksjoner som kommer til). I tillegg, siden hvert enkelt bevis typisk ogsÃ¥ fÃ¸lges av noe utgang, for eksempel data i kjeden. det er grenser for hvor mye data som kan skrives pÃ¥ kjeden, sammen med Ã©n bevis. Likevel blir kostnaden redusert gjennom en stÃ¸rrelsesorden og enda bedre tredoblet.

#### Redusert latens

I motsatt retning reduserer bestemmelsesmÃ¸nsteret holdningen av de store togene. Dette er resultatet av to faktorer:

1. Innkommende uttalelser kan pÃ¥vises**i parallell**(i motsetning til Ã¥ pÃ¥vise en svÃ¦rt stor sammenslÃ¥tt setning).
2. Det er ikke behov for Ã¥ vente til den siste erklÃ¦ringen i toget kommer i gang med innspillingen. Tvert imot kan bevisene kombineres med nye utsagn slik de kommer. Det betyr at sistnevnte erklÃ¦ring gÃ¥r inn i en tog, er omtrent tiden det tar Ã¥ bevise at den siste erklÃ¦ringen pluss tiden det tar Ã¥ vise en rekursiv Verifier-erklÃ¦ring (som deltar i alle disse utsagnene som allerede har Â«onboardedÂ» denne bestemte toget).

Vi utvikler og optimaliserer mÃ¥lheten av Ã¥ pÃ¥vise gjentakende Viser-pÃ¥stand. Det regner vi med Ã¥ nÃ¥ noen minutter i lÃ¸pet av noen fÃ¥ mÃ¥neder. Derfor kan en svÃ¦rt effektiv SHARP tilby latenser fra noen minutter til noen fÃ¥ timer, avhengig av handelslaget eller on-chain kostnadene per transaksjon. Dette representerer en meningsfull forbedring til SHARP.

#### Fasiliterer L3

Utviklingen av erklÃ¦ringen fra Recursive Verifier i Cairo Ã¥pner ogsÃ¥ for Ã¥ sende bevis til StarkNet. da denne erklÃ¦ringen kan bakes inn i en smartkontrakt med StarkNet Det gjÃ¸r det mulig Ã¥ bygge[L3 distribusjoner oppÃ¥ den offentlige StarkNet](https://medium.com/starkware/fractal-scaling-from-l2-to-l3-7fe238ecfb4f)(et L2-nettverk).

Det rekursive mÃ¸nsteret gjelder ogsÃ¥ for aggregering av stammer fra L3, som skal verifiseres ved et enkelt bevis pÃ¥ L2. Derfor oppnÃ¥s ogsÃ¥ hyperskalering der.

### Flere subtilt fordeler

#### Gjentakelse av sÃ¸knad

Tilbakefall gir ytterligere muligheter for plattformer og sÃ¸knader som Ã¸nsker Ã¥ skalere kostnadene og ytelsen ytterligere.

Hver STARK dokumentasjon pÃ¥ gyldigheten av en setning anvendt pÃ¥ noen inndata kjent som "offentlige inngang" (eller "program output" pÃ¥ Kairo-vilkÃ¥r). Konseptuelt komprimerer STARK rekursiv to bevis med*to*inndata i*ett*bevis med to innganger. Med andre ord, mens antall bevis reduseres, blir antall innsatsfaktorer holdt konstant. Disse innspillene brukes vanligvis av et program for Ã¥ oppdatere en viss tilstand pÃ¥ L1 (e. for Ã¥ oppdatere roten til en tilstand eller utfÃ¸re tilbaketrekking fra kjeden).

Hvis rekursive pÃ¥standen tillates Ã¥ vÃ¦re*programoppmerksom*, dvs. kjenner igjen semantikken til selve applikasjonen: det kan begge komprimere to projeksjoner i Ã©n*samt*kombinere de to innspillene i en. Den resulterende erklÃ¦ringen forholder seg til gyldigheten av den innlagte kombinasjonen basert pÃ¥ semantikk, Dermed vil navnet som vender gjentagende behandling (se tegning 3 for eksempel)..

![Tegning 3: Eksempel pÃ¥ realgjentakelse](/assets/recursive_starks_03.png "Tegning 3: Eksempel pÃ¥ realgjentakelse")

Her Statement 1 attester til en statlig oppdatering fra A til B og Statement 2 attester til en oppdatering fra B til C. Dato for utsagn 1 og egenerklÃ¦ring 2 kan kombineres i en tredje utsagn, der man kan bekrefte den direkte oppdateringen fra A til C. Ved Ã¥ anvende lignende logikk rekursivt, kan man redusere kostnadene ved statlig oppdatering svÃ¦rt betydelig opp til planhetskravet.

Et annet viktig eksempel pÃ¥ programgjentakelse er Ã¥ komprimere opprullingsdata fra flere bevis. For eksempel for en validitetsrulling som StarkNet, hver oppdatering av lagringsplass pÃ¥ L2 tas ogsÃ¥ med som overfÃ¸ringsdata fra L1 for Ã¥ sikre datatilgjengelighet. Imidlertid er det ikke nÃ¸dvendig Ã¥ sende flere oppdateringer for samme lagringselement, siden bare den endelige verdien av transaksjoner godkjent av den verifiserte dokumentasjonen er nÃ¸dvendig for datatilgjengelighet. Denne optimaliseringen er allerede utfÃ¸rt i en*enkel*StarkNet blokk. Ved Ã¥ generere et bevis per blokk, kan imidlertid Applicative Recursion comprimere denne opprullingsdataene over*flere*L2-blokker. Dette kan fÃ¸re til betydelig kostnadsreduksjon, og muliggjÃ¸r kortere blokkintervaller pÃ¥ L2, uten Ã¥ hindre skalerbarheten til L1 oppdateringer.

Verdt notat: Reaksjonen i sÃ¸knaden kan kombineres med program-agnostisk rekursjon som beskrevet tidligere. Disse to optimaliseringene er uavhengige.

#### Redusert leverandÃ¸rers kompleks kapasitet

Kompleksiteten til STARK-verifiserende er avhengig av hvilken type utsagn den er utformet for Ã¥ verifisere. Spesielt for Kairo-pÃ¥stander er kompleksiteten til verifiserer avhengig av de bestemte elementene som er tillatt i Kairo-sprÃ¥ket, og nÃ¦rmere bestemt brukes de stÃ¸ttede bygningsdelene (hvis vi bruker CPU metafor Cairo, som deretter er innebygde ekvivalente med mikrokretser i et CPU: beregninger som utfÃ¸res sÃ¥ ofte at de krever sin egne optimaliserte beregning).

Kairo-sprÃ¥ket utvikler seg fortsatt og tilbyr mer og mer nyttige bebygde byggelser. PÃ¥ den andre siden krever kun den rekursive viseren Ã¥ bruke en liten undergruppe av disse innebygde enhetene. Derfor kan en rekursiv SHARP vellykket stÃ¸tte alle uttalelser i Cairo ved Ã¥ stÃ¸tte hele sprÃ¥ket i de rekursive bekreftelsene. Spesielt trenger L1 Solidity Verifier bare verifisere rekursive bevis, og dermed kan vÃ¦re begrenset til et mer stabilt delsett av sprÃ¥ket Cairo : L1 Verifier trenger ikke holde fÃ¸lge med det nyeste og stÃ¸rste innebygde anlegget. Verifikasjon av kontinuerlige komplekse utsagn er med andre ord hevdet til L2, og etterlater L1 Verifier for Ã¥ verifisere enklere og mer stabile pÃ¥stander.

#### Redusert kaldstyrt footprint

FÃ¸r rekurjon, evnen til Ã¥ tilfÃ¸re flere instruksjoner til Ã¥ utfÃ¸re Ã©n verifikasjon var begrenset av den stÃ¸rste stÃ¸rrelsen pÃ¥ erklÃ¦ringen, som kunne bevises pÃ¥ tilgjengelige beregningstilfeller (og nÃ¥r det kunne ta Ã¥ generere slike bevis).

Ved tilbakefall er det ikke lenger nÃ¸dvendig Ã¥ vise sÃ¥ ekstremt store utsagn. Som et resultat mindre, rimeligere og mer tilgjengelige beregningstilfeller kan brukes (selv om det kan vÃ¦re behov for flere av de store monolittoperatÃ¸rene). Dermed kan bruken av behovsstyrte forekomster i mer fysiske og virtuelle miljÃ¸er enn det som var mulig tidligere.

### Summary

I tillegg tilbyr reformer for generell beregning nÃ¥ flere produksjonssystemer, inkludert StarkNet, pÃ¥ Mainnet Ethereum.

Fordelene med tilbakefall vil gradvis bli realisert, ettersom det fortsatt gir rom for nye forbedringer. og den vil snart levere hyperskala, kutte gassgebyrene og forbedre latensen ved Ã¥ lÃ¥se opp potensialet til parallellalisering.

Det vil gi betydelige kostnads- og forsinkelsesfordeler med seg, sammen med nye muligheter som for eksempel L3 og applicative-rekursjon. Det er forventet at ytterligere optimalisering av den gjentakende Viseren pÃ¥gÃ¥r og enda bedre ytelse og kostnadsfordeler vil bli gitt over tid.



**Gidi Kaempfer**, leder for Core Engineering, StarkWare