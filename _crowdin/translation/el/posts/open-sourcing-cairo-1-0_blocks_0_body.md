### TL;DR

* **Κάιρο 1.0 είναι ανοιχτού κώδικα! Αυτό είναι μόνο το πρώτο βήμα προς τον ανοικτό εφοδιασμό της στοίβας StarkNet.**
* Παρουσιάζουμε τώρα μια[πρώτη ματιά](https://github.com/starkware-libs/cairo)στο μεταγλωττιστή του Καΐρου 1.0. Τώρα μπορείτε να αρχίσετε να πειραματίζεστε με τον βασικό κώδικα του Καΐρου 1.0
* Το Κάιρο 1,0 στον πυρήνα του είναι πολύ παρόμοιο με το Rust
* Σκεφτείτε το ένα πρώτο γούστο, όχι μια κυκλοφορία. Περισσότερες βελτιώσεις βρίσκονται σε εξέλιξη. Η πρώτη έκδοση του μεταγλωττιστή έχει προγραμματιστεί για τις αρχές του Q1 το επόμενο έτος.
* Το Κάιρο 1.0 δεν υποστηρίζεται στο StarkNet, ακόμα. Θα υποστηριχθεί στο StarkNet το επόμενο έτος.

### Εισαγωγή

Το 2020, κυκλοφορήσαμε το[Κάιρο](https://eprint.iacr.org/2021/1063.pdf), μια εξαντλητική γλώσσα προγραμματισμού που υποστηρίζει επαληθεύσιμη υπολογισμό. Το Κάιρο ξεκίνησε ως γλώσσα συναρμολόγησης και σταδιακά έγινε πιο εκφραστικό. Πριν από δύο μήνες, ανακοινώσαμε το[Κάιρο 1.0](https://medium.com/starkware/cairo-1-0-aa96eefb19a0), το οποίο αντιμετωπίζει κάποια σημαντικά ζητήματα στην τρέχουσα κατάσταση:

* Ενώ η σύνταξη του Κάιρο έχει δει σημαντική βελτίωση από την έναρξή της, η εμπειρία του προγραμματιστή μπορεί πάντα να βελτιωθεί. Το Κάιρο 1.0 είναι μια πλήρως δακτυλογραφημένη γλώσσα εμπνευσμένη από τη σκουριά, κάνοντας τη γραφή της ίδιας λογικής πολύ ευκολότερη και λιγότερο επιρρεπής σε σφάλμα.
* Ο υπάρχων μεταγλωττιστής αναπτύσσεται στο ίδιο repo με το ίδιο το StarkNet καθιστώντας δυσκολότερη την παρακολούθηση των αλλαγών γλώσσας. Ο μεταγλωττιστής του Καΐρου 1.0 γράφεται από το προσκήνιο, επιτρέποντας την ταχύτερη ανάπτυξη των δυνατοτήτων και για περισσότερη συμμετοχή της κοινότητας.
* Κάθε υπολογισμός είναι πλέον αποδεδειγμένος. Επί του παρόντος, ένα πρόγραμμα του Καΐρου μπορεί να αποτύχει με συγκεκριμένες εισόδους (π.χ. φτάνοντας σε μια εντολή \`assert 1=2\` σε κάποιο κλάδο υπολογισμού), καθιστώντας τον υπολογισμό μη αποδεδειγμένο. Με το Κάιρο 1.0, τα προγράμματα μπορούν να αποδειχθούν σε κάθε πιθανό κλάδο. Αυτό είναι ιδιαίτερα σημαντικό για την προστασία και την αντίσταση λογοκρισίας DOS στο StarkNet.

Σήμερα σηματοδοτούμε το πρώτο ορόσημο για την επίτευξη των παραπάνω στόχων, καθώς κινούμαστε την ανάπτυξη σε δημόσιο ρεμπόρ, και**ανοικτού κώδικα Κάιρο 1. !**Οι προγραμματιστές μπορούν τώρα, για πρώτη φορά, να συντάξουν και να εκτελέσουν απλά προγράμματα του Καΐρου 1.0. Αυτό επιτρέπει στους προγραμματιστές να αρχίσουν να πειραματίζονται με το Κάιρο 1. και σταδιακά να εξοικειωθούν με τα νέα χαρακτηριστικά, ακόμη και αν, σε αυτό το στάδιο, δεν μπορούν να το εφαρμόσουν στο StarkNet μόλις ακόμα.

### Τρέχουσες δυνατότητες

Επί του παρόντος, μπορείτε να συντάξετε και να εκτελέσετε βασικά εγγενή προγράμματα του Καΐρου. Ενώ πολλές από τις βελτιώσεις σύνταξης/γλώσσας είναι ακόμα σε εξέλιξη, αυτό επιτρέπει να συνηθίσει στο Κάιρο 1.0 και να απολαύσετε αναβαθμίσεις όπως έρχονται.

**Σημειώστε ότι η εγγραφή συμβάσεων του StarkNet εξακολουθεί να μην υποστηρίζεται.**Η σύνταξη StarkNet (μεταβλητές αποθήκευσης / συμβάσεις κλήσεων / εκδηλώσεις και άλλες κλήσεις συστήματος) θα προστεθεί τις επόμενες εβδομάδες.

### Παραδείγματα κώδικα

Για να δείτε τις διαφορές μεταξύ της παλιάς σύνταξης και του Καΐρου 1. , έχουμε επιλέξει να δείξει μερικές διαφορετικές εφαρμογές / γεύσεις της εύρεσης του n’th Fibonacci αριθμό.

### Παράδειγμα Ι: Αντιστοίχιση εκφράσεων

Στο Κάιρο 1.0, μπορείτε να χρησιμοποιήσετε εκφράσεις που ταιριάζουν με[match](https://doc.rust-lang.org/rust-by-example/flow_control/match.html?highlight=match#match). Δεν θα φοβάστε πλέον εάν/άλλες δηλώσεις που μπορεί να προκαλέσουν ανάκληση αναφοράς!

![](/assets/code01.png)

### Παράδειγμα II: Τύποι δεδομένων

Ενώ το Κάιρο 0 συνεργάστηκε με πιλήματα και δείκτες, στο Κάιρο 1.0 έχουμε εγγενή πρόσβαση σε σύνθετους τύπους δεδομένων στη γλώσσα. Παρακάτω μπορείτε να βρείτε ένα παράδειγμα που δημιουργεί μια σειρά από τους πρώτους αριθμούς n Fibonacci.

![](/assets/code02.png)

Όπως μπορείτε να δείτε παραπάνω, αντί να δουλεύουμε απευθείας με δείκτες μνήμης, χρησιμοποιούμε το «Array::<felt>\` τον τύπο και τη συνάρτηση \`array_append\`.

### Παράδειγμα III: δομές & ιδιοκτησία

Ο παρακάτω κώδικας απεικονίζει τη χρήση δομών στο Κάιρο 1.0.

![](/assets/code03.png)

> Η ακόλουθη παράγραφος προορίζεται για τους Rustaceans μεταξύ του κοινού. Το Κάιρο 1.0 διαχειρίζεται τη μνήμη με παρόμοιο τρόπο με τη σκουριά. Συγκεκριμένα, χρησιμοποιεί τις έννοιες της[ιδιοκτησίας και του δανεισμού](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html). Έτσι, με την πρόσβαση σε ένα μέλος της δομής \`FibResult\` (σε αυτή την περίπτωση, \`result. alue\`), έχουμε μετακινήσει το \`result\`, πράγμα που σημαίνει ότι εκτός αν το FibResult είναι αντιγραφό, δεν μπορούμε να το έχουμε ξανά πρόσβαση στο \`result.index\`. Για να ξεπεράσουμε αυτό, προσθέτουμε το χαρακτηριστικό \`#\[derive(Copy)]\` του τύπου \`FibResult\`. Σε μελλοντικές εκδόσεις, θα προσθέσουμε αυτόματη αποδόμηση για δομές. Αυτό θα επιτρέψει τη μετακίνηση της ιδιοκτησίας ενός μέλους χωρίς να αγγίξει τα άλλα (συγκεκριμένα, ο παραπάνω κώδικας θα μεταγλωττίσει ακόμα και αν το \`FibResult\` δεν είχε το χαρακτηριστικό αντιγραφής).

**Ειδικότερα, σημειώστε ότι το Κάιρο 1.0 είναι εντελώς αφαιρετικά μακριά το πρωτότυπο (μη ντετερμινιστική μόνο ανάγνωση) μοντέλο μνήμης του Καΐρου.**

## Παράδειγμα IV: Διάδοση σφαλμάτων

Ο παρακάτω κώδικας υπολογίζει τον αριθμό n’th Fibonacci, αλλά σε αντίθεση με τα προηγούμενα παραδείγματα, όλες οι είσοδοι είναι του τύπου uint128. Σημειώστε ότι αυτό λύνει ένα σημαντικό σημείο πόνου στο χειρισμό uints στο Κάιρο 0. Εδώ, uint128 (και στο μέλλον uint256) είναι ντόπιοι τύποι.

![](/assets/0_s8bhjf_ade3carmi.png)

Η προσθήκη δύο ακέραιων 128 bit μπορεί να προκαλέσει υπερχείλιση. Ο παραπάνω κωδικός χρησιμοποιεί το[Option enum](https://doc.rust-lang.org/rust-by-example/std/option.html)και τον[διαχειριστή ερωτηματικού](https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html)για να χειριστεί την περίπτωση υπερχείλισης σε μία από τις ενδιάμεσες προσθήκες. Σύγκριση με την[τρέχουσα](https://github.com/starkware-libs/cairo-lang/blob/9889fbd522edc5eff603356e1912e20642ae20af/src/starkware/cairo/common/uint256.cairo#L31)uint256 σύνταξη προσθήκης, όπου η συνάρτηση \`unit256_check\` έπρεπε να κληθεί για να εγγυηθεί την ευρωστία. Επιπλέον, στο εγγύς μέλλον θα προσθέσουμε την έννοια του \`panic\` στη γλώσσα (παρόμοια με την[μακροεντολή πανικού](https://doc.rust-lang.org/rust-by-example/std/panic.html)σε σκουριά), και απλά λάθη όπως υπερχείλιση προσθήκης θα είναι αδιάκριτα και θα διαδίδονται αυτόματα, πράγμα που σημαίνει ότι δεν θα χρειαστεί να χρησιμοποιήσετε \`Option\` ή \`? ` κατά την προσθήκη uints.

## Δοκιμάστε το μόνοι σας

Τώρα μπορείτε να μεταγλωττίσετε και να εκτελέσετε προγράμματα που υποστηρίζονται από το Κάιρο 1.0! Ακολουθήστε αυτές τις[οδηγίες](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-runner)σχετικά με τον τρόπο χρήσης της εντολής \`cairo-run\`. Σημειώστε ότι κάτω από την κουκούλα, το[Rust Cairo VM](https://github.com/lambdaclass/cairo-rs), που αναπτύχθηκε από[Lambdaclass](https://lambdaclass.com/), χρησιμοποιείται για εκτέλεση.

Μπορείτε να βρείτε περισσότερα παραδείγματα που θα σας βοηθήσουν να ξεκινήσετε[εδώ](https://github.com/starkware-libs/cairo2/tree/main/examples). Σημειώστε ότι αυτό είναι μόνο η πρώτη ματιά στην ανάπτυξη του μεταγλωττιστή · στις επόμενες εβδομάδες θα βελτιώσουμε το CLI μαζί με τον μεταγλωττιστή.

## Μελλοντικά Σχέδια

Το επίκεντρο της πρώτης έκδοσης του μεταγλωττιστή, το οποίο έχει προγραμματιστεί για τις αρχές του Q1, υποστηρίζει όλες τις υπάρχουσες λειτουργίες του StarkNet στο Κάιρο 1.0. Επιπλέον, εργαζόμαστε για την επέκταση των δυνατοτήτων του μεταγλωττιστή του Καΐρου 1.0. Τις επόμενες εβδομάδες, μπορείτε να περιμένετε:

* Δυνατότητες StarkNet — συγγραφή έξυπνων συμβάσεων και χρήση κλήσεων συστήματος.
* Βρόχοι
* Νέες λειτουργίες βιβλιοθήκης
* Βελτιωμένος διακομιστής γλώσσας
* Μια εγγενής έννοια του αερίου StarkNet

Φροντίστε να μείνετε συντονισμένοι και να παρακολουθείτε την πρόοδο του μεταγλωττιστή!