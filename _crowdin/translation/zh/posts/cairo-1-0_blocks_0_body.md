### TL;DR

* 开罗1.0是两年前[引入开罗](https://medium.com/starkware/hello-cairo-3cb43b13b209)之后的第一个主要版本
* Cairo 1.0 将为开发者提供一个更安全、更简单、更易使用的编程语言
* 开罗1.0的中心将是**Sierra**，它是一个中间代表层，为开罗方案带来更大的长期稳定。
* Sierra lease Cairo to service in a permissions without network:\
  -**Protecting the network**: it allows more strong DoS protection\
  -**Protecting the user**: it allows Easud level registance resistance Cairo 1。 将以多种方式实现StarkNet。 它也会影响[基因组](https://medium.com/starkware/regenesis-starknets-no-sweat-state-reset-e296b12b80ae)。 我们将在今后几周内发布更多有关雷杰尼斯的信息。

### 导 言

2020年，我们发行了开罗，它是一种完整的编程语言，并在支持使用STARK进行可核查的计算方面迈出了一大步。 今天，我们宣布**Cairo 1.0**，是迄今为止开罗取得的最大进步。 它将采用一种经过改进的语言，其特点将提高可用性、安全性和方便性。 它旨在支持StarkNet作为无权限网络的要求，使协议变得更简单、更安全。\
开发已经在进行中，我们预计第一次发布将很快完成。

在这个职位上，我们将描述开罗迄今的旅程，并详细介绍即将到来的特点。

### 开罗之旅：

在2020年之前，建立一般计算的STARK可证明的程序需要特殊知识。 只有那些理解STARK背后的复杂数学的人才能做到。 具体而言，就每项业务逻辑而言，即： 每次计算都需要生成代数介质表示器——代表特定计算的一组多项约束器。

开罗之所以诞生，是因为认识到应向各地的开发商提供可核查的计算方法。 开罗使开发人员能够利用STARK的力量。

自那时以来，开发界一直在开罗积极地建设起来。 今天在蓬勃发展的StarkNet生态系统中的一切都以开罗为基础。 [StarkNet](https://starkware.co/starknet/)and[StarkEx](https://starkware.co/starkex/)之间，开罗驱动的应用程序已经处理了超过220M的交易。 挖掘了超过65M的NFT，处理了价值700B的贸易，所有这些交易都在以太坊结算。

虽然开罗国家统计数据库开放，但它原先是作为一种集合语言设计的，因此是作为一种低级语言撰写的。

![开罗编写的早期方案示例](/assets/cairocode_01.png "开罗编写的早期方案示例")

由于开发人员的反馈和[StarkNet](https://starkware.co/starknet/)的上升，我们逐渐使开罗变得更加明确，对开发人员更加友好。

![ERC-20开罗合同中的一个例子表明如果声明、错误和UINT256图书馆支持变量](/assets/cairocode_02.png "ERC-20开罗合同中的一个例子表明如果声明、错误和UINT256图书馆支持变量")

但我们很快就得出结论，现在是向前迈出一大步的时候了。 不但不能逐步改善开罗，反而进行更大胆的改革。

### Cairo 1.0

开罗1 我们已经从头建立了一个完整的编译器，它将为开发人员提供安全功能。 并使他们能够以更简单、更明确的方式编写合同。

#### 引进Sierra：确保每个开罗运行都能够被证明是正确的

在开罗增加的主要部分。 是塞拉利昂(**S**afe**I**nt**e**rmediate**R**ep**r**ent**a**). 塞拉利昂构成开罗1.0至开罗字节代码之间新的中间代表层。 Sierra的目标是确保每次开罗运行——即开罗方案及其投入——都能得到证明（见下文）。

塞拉利昂许诺开罗会议将制定更好的未来防灾守则。 由于StarkNet的合同在改进基本系统的情况下不必重新编纂（e），这使得情况更加稳定。 ，CPU AIR structure change, 改进最终翻译从塞拉里昂到开罗字节代码)。

**验证每一个开罗的运行。**在老的开罗，开罗的运行可能导致三种情况——TRUE、FALSE或失败。 无法验证失败的运行。 Sierra确保开罗的运行永远不会失败，只能导致TRUE或FALSE。 这反过来又确保每次开罗会议都能得到证明。

塞拉利昂的这种引进对作为无许可网络的StarkNet具有重要影响。 塞拉利昂确保甚至恢复的交易都可以列入StarkNet区块。 此属性将使StarkNet协议能够保持简洁而无需添加复杂的加密经济机制。\
两个有意义的示例：

1. 序列器将能够在恢复交易时收取费用，从而允许StarkNet以既定方式防止序列器DoS。
2. 执行强行的L1交易将是可能的，允许StarkNet继承Etherum的全部抵制性。

### **语言特性**

开罗1.0将为编程语言本身提供许多改进。 并非下面列出的所有内容都是第一次发布的一部分，但它是路径图的一部分。

#### **改进语法**

* 没有*本地*和*节奏*。 我们现在只需要*让*来统治他们所有的变量。
* 如果</em>语句语法改进了*</li> </ul>

```python
#旧的
如果是cond ！ 0 请注意，
  tempvar x = x+1;
其他，
  tempvar x = x;
}
__________________________________
#New
if cond Power x = x + 1; }
```

#### **类型安全担保**

编译器将使用强大的打字来提高代码的安全性。 例如：

* 指针总是指向初始化内存。
* 词典总是会被挥舞，而不是让程序员来调用squash_dict。

#### **使用语言构造更加容易。**

例如：

* 用于循环

```
让和 = 0
for x in iter 密切相关,
  和 = 和 + x;
}
```

* 布尔表达式
* 整数(普通整数除以 👯)
* 相关类型的过度保护
* 布尔条件

```
#Old
If cond1:
  if cond2:
       # Some code
  else if cond3:
       # Same code
__________________________________
#New
If cond1 && (cond2 || cond3) { … }
```

#### **一个完整的类型系统**

* 摘要数据类型（即： 按次列数)

```
enum Option<T> {
 Some: T,
 None,
}
匹配结果 {
 Some(r) => {..},
 None => {..},
}
```

* 特性

```
特性添加<Uint256> ·
    fn add(…) { … }


let a: Uint256 = 1;
let b: Uint256 = 4;
a + b; // 评价为5型Uint256。
```

#### **更直观的库**

(如，二维数组)

* Dict<Uint256, MyStruct>;
* 数组<MyOtherStruct>;

#### **更优化的代码**

无需明确指定本地变量的状态分配——自动检测到并自动完成。

#### **更好的编译器集成**

促进更好的发展教育支助、一揽子管理和更好地促进社区贡献。

### **五. 结论**

在开罗首次用于生产两年之后，我们正在开发开罗1.0版，这将提供更好的表达性、安全性和语法。 它将取得很大进展，使开发人员更容易写入StarkNet合同。

在另一篇文章中，我们将很快介绍开罗1的情况。 StarkNet的regenesis将产生效果，开发者将如何为其发布做好准备。