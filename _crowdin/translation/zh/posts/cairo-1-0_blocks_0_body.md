### TL;DR

* Cairo 1.0是继两年前[引入Cairo](https://medium.com/starkware/hello-cairo-3cb43b13b209)之后的第一个主要版本
* Cairo 1.0将为开发者提供更安全、更简单、更可用的编程语言
* Cairo 1.0 的核心将是**Sierra**，这是一个中间表示层，可为 Cairo 程序提供更高的长期稳定性
* Sierra 推动 Cairo 在无需许可的网络中提供服务：\
  -**保护网络**：它允许更强大的 DoS 保护\
  -**保护用户**：它允许以太坊级审查制度 Cairo 1.0 将以多种方式影响 StarkNet。 它还会影响[再生](https://medium.com/starkware/regenesis-starknets-no-sweat-state-reset-e296b12b80ae)。 我们将在未来几周内发布有关 Regenesis 的更多信息。

### 导 言

2020 年，我们发布了图灵完备的编程语言 Cairo，并在支持使用 STARK 进行可验证计算方面迈出了一大步。 今天，我们宣布**Cairo 1.0**，这是 Cairo 迄今为止最大的进步。 它将引入一种改进的语言，其功能将增强可用性、安全性和便利性。 它旨在支持 StarkNet 作为无许可网络的要求，使协议变得更简单、更安全。\
开发已经在进行中，我们预计第一个版本很快就会发布。

在这篇文章中，我们将描述开罗迄今为止的旅程，并分享即将推出的功能的详细信息。

### 开罗之旅

到 2020 年，需要利基知识来构建可 STARK 证明的通用计算程序。 只有那些了解 STARK 背后复杂数学原理的人才有可能做到这一点。 具体来说，对于每个业务逻辑，即每个计算，都需要生成代数中间表示（AIR）——一组表示特定计算的多项式约束。

Cairo 的诞生源于这样一种认识：应向世界各地的开发人员提供可验证的计算。 Cairo 使开发人员能够利用 STARK 的力量。

此后，开发者社区抓住开罗的机遇，热情地进行建设。 如今蓬勃发展的 StarkNet 生态系统中的一切都基于开罗。 在[StarkNet](https://starkware.co/starknet/)和[StarkEx](https://starkware.co/starkex/)之间，Cairo 支持的应用程序已经处理了超过 2.2 亿笔交易，铸造了超过 6500 万个 NFT，并处理了价值 700B 美元的交易，所有交易均在以太坊上结算。

虽然 Cairo 使 STARK 易于使用，但它最初被设计为汇编语言，因此它是作为低级语言编写的。

![在开罗编写的早期程序的示例](/assets/cairocode_01.png "在开罗编写的早期程序的示例")

在开发者反馈和[StarkNet](https://starkware.co/starknet/)崛起的推动下，我们逐渐使 Cairo 更具表现力，对开发者更加友好。

![ERC-20 Cairo 合约中的示例展示了对变量、if 语句、错误和 UINT256 库的支持](/assets/cairocode_02.png "ERC-20 Cairo 合约中的示例展示了对变量、if 语句、错误和 UINT256 库的支持")

但我们很快得出结论，是时候向前迈出一大步了，而不是对开罗进行渐进式改进，而是进行更大胆的转型。

### Cairo 1.0

对于 Cairo 1.0，我们从头开始构建了一个全新的编译器，它将为开发人员提供安全功能，并允许他们以更简单、更具表现力的方式编写合约。

#### Sierra 简介：确保每一次开罗跑步都能得到验证

Cairo 1.0 中主要添加的是 Sierra (**S**afe**I**nt**e**rmediate**R**ep**r**esent**a**)。 Sierra 构成了 Cairo 1.0 和 Cairo 字节码之间的新中间表示层。 Sierra 的目标是确保每一次 Cairo 运行（即 Cairo 程序及其输入）都可以得到证明（请参阅下文）。

Sierra 承诺开罗开发人员提供更好的面向未来的代码。 在底层系统改进的情况下（例如，CPU AIR 架构更改、从 Sierra 到 Cairo 字节码的最终翻译的改进），StarkNet 合约不需要重新编译，这一事实提供了进一步的稳定性。

**证明每一次开罗跑步。**在旧开罗，开罗运行可能会导致三种情况 - TRUE、FALSE 或失败。 无法证明失败的运行。 Sierra，确保开罗运行永远不会失败，并且只能得出 TRUE 或 FALSE。 这反过来又确保了每次开罗跑步都能得到验证。

Sierra 的引入对于 StarkNet 作为无需许可的网络具有重要意义。 Sierra 确保即使是恢复的交易也可以包含在 StarkNet 区块中。 这一特性将使 StarkNet 协议保持精简和简单，而无需添加复杂的加密经济机制。\
两个有意义的例子：

1. Sequencer 将能够对恢复的交易收取费用，从而使 StarkNet 能够以完善的方式防止 Sequencer DoS。
2. 实施强制 L1 交易将成为可能，从而使 StarkNet 继承以太坊的完全抗审查能力。

### **语言特点**

Cairo 1.0 将对编程语言本身进行许多改进。 并非下面列出的所有内容都将成为第一个版本的一部分，但它是路线图的一部分。

#### **改进的语法**

* 不再有*local*和*tempvar*。 我们现在只需要*let*来规则所有变量。
* 改进了*if*语句语法

```python
#旧
if cond != 0 {
  tempvar x = x+1;
} else {
  临时变量 x = x;
}
__________________________________
#New
if cond { x = x + 1; }
```

#### **类型安全保证**

编译器将使用强类型来提高代码的安全性。 例如：

* 指针将始终指向已初始化的内存。
* 字典总是会被压缩，而不是将调用squash_dict的责任留给程序员。

#### **更容易使用语言结构**

例如：

* For 循环

```
让 sum = 0
for x in iter {
  sum = sum + x;
}
```

* 布尔表达式
* 整数（使用常规整数除法👯）
* 相关类型的溢出保护
* 布尔条件

```
#旧
If cond1:
  if cond2:
       # 一些代码
  else if cond3:
       # 相同代码
__________________________________
#New
If cond1 && (cond2 || cond3) { … }
```

#### **成熟的类型系统**

* 抽象数据类型（即 类似 Rust 的枚举）

```
enum Option<T> {
 Some: T,
 None,
}
匹配结果 {
 Some(r) => {..},
 None => {..},
}
```

* 性状

```
特征 添加<Uint256> {
    fn add(…) { … }
}

让 a: Uint256 = 1;
让b: Uint256 = 4;
+b； // 计算结果为 Uint256 类型的 5。
```

#### **更直观的库**

（例如字典、数组）

* 字典<Uint256, MyStruct>；
* 大批<MyOtherStruct>;

#### **更优化的代码**

无需显式声明局部变量的分配——自动检测并自动完成。

#### **更好的编译器集成**

实现更好的 IDE 支持、包管理和更好地促进社区贡献。

### **结论**

Cairo 首次用于生产两年后，我们正在开发 Cairo 1.0，它将提供改进的可表达性、安全性和语法。 它将向前迈出一大步，让开发者能够更轻松地编写他们的 StarkNet 合约。

在即将发布的另一篇文章中，我们将分享有关 Cairo 1.0 将如何影响 StarkNet 再生以及开发人员应如何为其发布做准备的更多详细信息。