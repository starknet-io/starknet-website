### TL;DR

* La prova recursiva est√† en directe a Mainnet, escalant les aplicacions StarkEx i StarkNet amb una √∫nica prova
* Augmenta l'escala i ofereix beneficis en costos i lat√®ncia (una aparici√≥ rara i emocionant d'escala i lat√®ncia que es mouen en t√†ndem, i no √©s una compensaci√≥)
* Prepara l'escenari per a L3 i altres avantatgesVes a llegir la publicaci√≥ del bloc sobre[Prova recursiva](https://medium.com/@starkware/recursive-starks-78f8dd401025). √âs una cosa genial üòâ

### Ampliant!

Les proves recursives, impulsades pel c√†lcul general del Caire, ara estan en producci√≥. Aix√≤ suposa un gran impuls a la pot√®ncia de l'escala L2 amb STARK. Proporcionar√† r√†pidament un augment m√∫ltiple del nombre de transaccions que es poden escriure a Ethereum mitjan√ßant una √∫nica prova.

Fins ara, l'escala STARK ha funcionat "agregant" desenes o fins i tot centenars de milers de transaccions en una √∫nica prova, que es va escriure a Ethereum. Amb la recursivitat, moltes d'aquestes proves es poden "agregar" en una √∫nica prova.

Aquest m√®tode es troba ara en producci√≥ per a multitud d'aplicacions basades en El Caire: aplicacions que s'executen a StarkEx, el motor d'escalat SaaS de StarkWare i StarkNet, el paquet acumulat sense perm√≠s.

### La hist√≤ria fins ara

Des de la primera prova a Mainnet, el mar√ß de 2020, els desenvolupaments seg√ºents han donat forma a com s'utilitzen els STARK.

### Escalat basat en STARK

El juny de 2020 es va desplegar la primera soluci√≥ d'escala basada en STARK,[StarkEx](https://youtu.be/P-qoPVoneQA), a Ethereum Mainnet. StarkEx t√© un Prover que realitza grans c√†lculs fora de la cadena i produeix una prova STARK per a la seva correcci√≥, i un verificador que verifica aquesta prova en cadena. Les limitacions d'aquest primer desplegament van ser "escrites a m√†" pels enginyers de StarkWare, limitant aix√≠ molt la velocitat de les funcions de StarkEx. Vam concloure que es necessita un llenguatge de programaci√≥ per donar suport a la demostraci√≥ de la computaci√≥ general: El Caire.

#### El Caire

A l'estiu del 2020, el Caire va fer la seva primera aparici√≥[a Ethereum Mainnet](https://medium.com/starkware/hello-cairo-3cb43b13b209). Cairo significa CPU Algebraic Intermediate Representation (AIR) i inclou un √∫nic AIR que verifica el conjunt d'instruccions d'aquesta "CPU". Va obrir la porta per a la codificaci√≥ de proves per a una l√≤gica empresarial m√©s complexa, per a declaracions computacionals arbitr√†ries i per fer-ho d'una manera m√©s r√†pida i segura. Un programa Cairo pot provar l'execuci√≥ de la l√≤gica d'una √∫nica aplicaci√≥. Per√≤ un programa del Caire tamb√© pot ser una concatenaci√≥ de m√∫ltiples aplicacions d'aquest tipus: SHARP.

#### AGUT

SHARP, un provador compartit, pren transaccions de diverses aplicacions separades i les demostra totes en una √∫nica prova STARK. Les aplicacions combinen els seus lots de transaccions, omplint la capacitat d'una prova STARK m√©s r√†pidament. Les transaccions es processen a un ritme i lat√®ncia millorats. La seg√ºent frontera: proves recursives, per√≤ no nom√©s per a una mica de l√≤gica codificada, sin√≥ m√©s aviat per a**c√†lcul general**.

Per entendre tot el benefici de la prova recursiva, val la pena entendre una mica m√©s sobre com SHARP feia la prova (no recursiva) fins ara. El dibuix 1 representa un flux no recursiu t√≠pic:

![Dibuix 1: un flux de prova t√≠pic no recursiu](/assets/recursive_starks_01.png "Dibuix 1: un flux de prova t√≠pic no recursiu")

Aqu√≠ les declaracions arriben amb el temps. Quan s'arriba a un determinat llindar de capacitat (o de temps), es genera una declaraci√≥ combinada gran (tamb√© conegut com Train). Aquesta declaraci√≥ combinada nom√©s es prova un cop s'han rebut totes les declaracions individuals. Aquesta demostraci√≥ triga molt de temps a demostrar-se (aproximadament la suma del temps que es necessita per demostrar cada afirmaci√≥ individualment).

La prova de declaracions extremadament grans es veu limitada finalment pels recursos inform√†tics disponibles, com ara la mem√≤ria. Abans de la recursivitat, aquesta era efectivament la barrera d'escalabilitat limitant de la prova STARK.

### Qu√® √©s la demostraci√≥ recursiva?

Amb les proves STARK, el temps que es necessita per demostrar una declaraci√≥ √©s aproximadament lineal amb el temps que es triga a executar la sent√®ncia. A m√©s, si la demostraci√≥ d'una afirmaci√≥ requereix un temps T, aleshores verificar la demostraci√≥ requereix un temps aproximadament log(T), que normalment s'anomena "compressi√≥ logar√≠tmica". En altres paraules, amb els STARK dediques molt menys temps a verificar l'enunciat que a calcular-lo.

[El Caire](https://starkware.co/cairo/)permet expressar enunciats computacionals generals que poden ser demostrats per proves STARK i verificats pels verificadors STARK corresponents.

Aqu√≠ √©s on apareix l'oportunitat de realitzar[recursivitat](https://en.wikipedia.org/wiki/Recursion): de la mateixa manera que escrivim un programa del Caire que demostra la correcci√≥ de milers de transaccions, tamb√© podem escriure un programa del Caire que verifiqui m√∫ltiples proves STARK. Podem generar una √∫nica prova que acrediti la validesa de m√∫ltiples proves "amunt". Aix√≤ √©s el que anomenem demostraci√≥ recursiva.

A causa de la compressi√≥ logar√≠tmica i el temps de prova aproximadament lineal, la prova d'una verificaci√≥ d'una prova STARK triga un temps relativament curt (s'espera que sigui uns minuts en un futur proper).

Quan s'implementa Recursion, SHARP pot provar les declaracions a la seva arribada. Les seves proves es poden fusionar una i altra vegada en proves recursives en diversos patrons fins que, en un moment determinat, la prova resultant s'envia a un contracte de verificador en cadena. Al dibuix 2 es mostra un patr√≥ t√≠pic:

![Dibuix 2: un flux de demostraci√≥ recursiu t√≠pic.](/assets/recursive_starks_02.png "Dibuix 2: un flux de demostraci√≥ recursiu t√≠pic.")

### Beneficis immediats de la demostraci√≥ recursiva

#### Cost redu√Øt en cadena

D'entrada, aconseguim la "compressi√≥" de m√∫ltiples proves en una, la qual cosa implica un cost de verificaci√≥ a la cadena m√©s baix per transacci√≥ (on cada declaraci√≥ pot incloure moltes transaccions).

Amb la recursivitat, s'elimina la barrera dels recursos computacionals (per exemple, la mem√≤ria) que limitava la mida de les proves fins ara, ja que cada declaraci√≥ de mida limitada es pot provar per separat. Per tant, quan s'utilitza la recursivitat, la mida efectiva de la recursivitat del tren √©s gaireb√© il¬∑limitada i el cost per transacci√≥ es pot reduir en ordres de magnitud.

En termes pr√†ctics, la reducci√≥ dep√®n de la lat√®ncia acceptable (i del ritme al qual arriben les transaccions). A m√©s, com que cada prova normalment tamb√© s'acompanya d'alguna sortida, com ara dades en cadena, hi ha l√≠mits a la quantitat de dades que es poden escriure en cadena juntament amb una √∫nica prova. No obstant aix√≤, reduir els costos en un ordre de magnitud i encara millor √©s trivialment assolible.

#### Lat√®ncia redu√Øda

El patr√≥ de prova recursiva redueix la lat√®ncia de provar grans trens de declaracions. Aquest √©s el resultat de dos factors:

1. Les declaracions entrants es poden demostrar**en paral¬∑lel**(en lloc de demostrar una declaraci√≥ combinada extremadament gran).
2. No cal esperar fins que arribi l'√∫ltima declaraci√≥ al Tren per comen√ßar a demostrar. M√©s aviat, les proves es poden combinar amb noves declaracions a mesura que arriben. Aix√≤ vol dir que la lat√®ncia de l'√∫ltima declaraci√≥ que s'uneix a un Train, √©s aproximadament el temps que triga a demostrar aquesta √∫ltima declaraci√≥ m√©s el temps que triga a provar una declaraci√≥ del verificador recursiu (que d√≥na fe de totes aquelles declaracions que ja han "incorporat" aquesta declaraci√≥). Tren particular).

Estem desenvolupant i optimitzant activament la lat√®ncia de la prova de la declaraci√≥ del verificador recursiu. Esperem que aix√≤ arribi a l'ordre d'uns minuts en pocs mesos. Per tant, un SHARP altament eficient pot oferir lat√®ncies des d'uns quants minuts fins a unes poques hores, depenent de la compensaci√≥ versus el cost per transacci√≥ a la cadena. Aix√≤ representa una millora significativa de la lat√®ncia de SHARP.

#### Facilitant L3

El desenvolupament de la declaraci√≥ del verificador recursiu al Caire tamb√© obre la possibilitat d'enviar proves a StarkNet, ja que aquesta declaraci√≥ es pot incorporar a un contracte intel¬∑ligent de StarkNet. Aix√≤ permet construir[desplegaments L3 a la part superior de la StarkNet](https://medium.com/starkware/fractal-scaling-from-l2-to-l3-7fe238ecfb4f)p√∫blica (una xarxa L2).

El patr√≥ recursiu tamb√© s'aplica a l'agregaci√≥ de proves de L3, que s'han de verificar mitjan√ßant una √∫nica prova a L2. Per tant, tamb√© s'aconsegueix una hiperescala.

### Beneficis m√©s subtils

#### Recurs aplicatiu

La recursivitat obre encara m√©s oportunitats per a plataformes i aplicacions que volen augmentar encara m√©s el seu cost i rendiment.

Cada prova STARK d√≥na fe de la validesa d'una declaraci√≥ aplicada a alguna entrada coneguda com a "entrada p√∫blica" (o "sortida del programa" en termes del Caire). Conceptualment, la recursivitat STARK comprimeix dues proves amb*dos*entrades en*una*prova amb dues entrades. En altres paraules, mentre es redueix el nombre de proves, el nombre d'entrades es mant√© constant. Aquestes entrades s√≥n normalment utilitzades per una aplicaci√≥ per actualitzar algun estat a L1 (per exemple, per actualitzar una arrel d'estat o realitzar una retirada en cadena).

Si es permet que la declaraci√≥ recursiva sigui**, √©s a dir, reconeix la sem√†ntica de l'</em>en si, pot comprimir dues proves en una*i combinar les dues entrades en una. La declaraci√≥ resultant d√≥na fe de la validesa de la combinaci√≥ d'entrada basada en la sem√†ntica de l'aplicaci√≥, d'aqu√≠ el nom de recursivitat aplicativa (vegeu el dibuix 3, per a un exemple).</p>

![Dibuix 3: Exemple de recursivitat aplicativa](/assets/recursive_starks_03.png "Dibuix 3: Exemple de recursivitat aplicativa")

Aqu√≠, la declaraci√≥ 1 d√≥na fe d'una actualitzaci√≥ de l'estat d'A a B i la declaraci√≥ 2 d√≥na fe d'una nova actualitzaci√≥ de B a C. Les proves de la declaraci√≥ 1 i la declaraci√≥ 2 es poden combinar en una tercera declaraci√≥, que atesti l'actualitzaci√≥ directa de l'A a la C. Aplicant una l√≤gica similar de manera recursiva, es pot reduir el cost de les actualitzacions d'estat molt significativament fins al requisit de lat√®ncia final.

Un altre exemple important de recursivitat aplicativa √©s comprimir les dades acumulades de m√∫ltiples proves. Per exemple, per a una acumulaci√≥ de validesa com StarkNet, totes les actualitzacions d'emmagatzematge a L2 tamb√© s'inclouen com a dades de transmissi√≥ a L1, per garantir la disponibilitat de dades. Tanmateix, no cal enviar diverses actualitzacions per al mateix element d'emmagatzematge, ja que nom√©s es requereix el valor final de les transaccions acreditades per la prova verificada per a la disponibilitat de dades. Aquesta optimitzaci√≥ ja es realitza dins d'un bloc StarkNet*√∫nic*. Tanmateix, en generar una prova per bloc, la recursivitat aplicativa pot comprimir aquestes dades acumulades en*blocs m√∫ltiples*L2. Aix√≤ pot comportar una reducci√≥ de costos significativa, permetent intervals de bloc m√©s curts a la L2, sense sacrificar l'escalabilitat de les actualitzacions de la L1.

Val la pena tenir en compte: la recursivitat aplicativa es pot combinar amb la recursivitat independent de l'aplicaci√≥, tal com es mostra anteriorment. Aquestes dues optimitzacions s√≥n independents.

#### Reducci√≥ de la complexitat del verificador en cadena

La complexitat del verificador STARK dep√®n del tipus d'afirmacions que est√† dissenyat per verificar. En particular, per a les declaracions del Caire, la complexitat del verificador dep√®n dels elements espec√≠fics permesos en l'idioma del Caire i, m√©s concretament, dels incorporats admesos (si fem servir la met√†fora de la CPU per al Caire, els integrats s√≥n l'equivalent de micro -circuits en una CPU: c√†lculs realitzats amb tanta freq√º√®ncia que requereixen el seu propi c√†lcul optimitzat).

L'idioma del Caire continua evolucionant i oferint incorporacions cada cop m√©s √∫tils. D'altra banda, el verificador recursiu nom√©s requereix utilitzar un petit subconjunt d'aquests integrats. Per tant, un SHARP recursiu pot suportar amb √®xit qualsevol declaraci√≥ al Caire donant suport al llenguatge complet als verificadors recursius. Concretament, el verificador de solidesa L1 nom√©s necessita verificar proves recursives i, per tant, es pot limitar a un subconjunt m√©s estable de l'idioma del Caire: el verificador L1 no necessita estar al dia amb els √∫ltims i millors incorporats. En altres paraules, la verificaci√≥ d'enunciats complexes en constant evoluci√≥ queda relegada a L2, deixant que el verificador L1 verifici declaracions m√©s simples i estables.

#### Reducci√≥ de la petjada inform√†tica

Abans de la recursivitat, la capacitat d'agregar diverses declaracions en una prova estava limitada per la mida m√†xima de la declaraci√≥ que es podia demostrar a les inst√†ncies de c√†lcul disponibles (i el temps que podia trigar a generar aquestes proves).

Amb la recursivitat, ja no hi ha necessitat de demostrar afirmacions tan grans. Com a resultat, es poden utilitzar inst√†ncies de c√†lcul m√©s petites, menys costoses i m√©s disponibles (tot i que es poden necessitar m√©s que amb grans provadors monol√≠tics). Aix√≤ permet desplegar inst√†ncies de prova en m√©s entorns f√≠sics i virtuals del que era possible abans.

### Resum

Les proves recursives de c√†lcul general ara serveixen a diversos sistemes de producci√≥, incl√≤s StarkNet, a Mainnet Ethereum.

Els avantatges de la recursivitat es realitzaran gradualment, ja que continua permetent noves millores, i aviat oferir√† una gran escala, reduir√† les tarifes del gas i millorar√† la lat√®ncia al desbloquejar el potencial de paral¬∑lelitzaci√≥.

Aportar√† importants beneficis de costos i lat√®ncia, juntament amb noves oportunitats com L3 i recursivitat aplicativa. L'optimitzaci√≥ addicional del verificador recursiu est√† en curs i s'espera que s'ofereixin fins i tot un millor rendiment i beneficis en costos amb el temps.



**Gidi Kaempfer**, cap d'enginyeria b√†sica, StarkWare