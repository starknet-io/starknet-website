### TL;DR

* 有効性のロールアップは、L1と同じ方法でスループットに限定されません。 これにより、L2の有効性ロールアップにおいて、潜在的にはるかに高いTPSが発生します。
* StarkNetパフォーマンスロードマップは、シーケンサーというシステムの重要な要素に対応します。
* パフォーマンス改善のためのロードマップをご紹介します:\
  — シーケンサー並列化\
  — カイロのVMの新しい錆実装\
  — シーケンサーのrustの再実装
* 彼らがそうであるように戦いテストされている諺はボトルネックではなく、今よりもはるかに多くを処理することができます!

### はじめに

StarkNetは、ほぼ1年前にMainnetで発売されました。 機能性に焦点を当てた StarkNet の構築を始めました。 今、私たちはStarkNetのエクスペリエンスを向上させる一連のステップでパフォーマンスを向上させることにフォーカスをシフトします。

この記事では、有効性ロールアップにのみ適用可能な幅広い最適化がある理由を説明します。 これらのステップをStarkNetに実施する計画を共有します。 これらのステップのいくつかはすでに11月16日にテストネットでリリースされたStarkNet Alpha 0.10.2で実装されています。 しかし、解決策について議論する前に、制限とその原因について検討してみましょう。

### ブロック制限: 有効性とL1の間のロールアップ

ブロックチェーンのスケーラビリティを向上させ、TPSを向上させるための潜在的なアプローチは、ブロックタイムを一定に保ちながら(ガス/サイズに関して)ブロックの制限を解除することです。 これはブロック生成者(L1のバリデーター)からのより多くの労力を必要とします。 L2のシーケンサーにより、これらのコンポーネントをより効率的に実装する必要があります。 ここでは、StarkNetシーケンサーの最適化にフォーカスを移します。ここでは、以下のセクションで詳しく説明します。

ここで自然な質問が起こります。 シーケンサーの最適化が有効ロールアップに限定されるのはなぜですか? L1に同じ改善を実施し、妥当性ロールアップの複雑さを完全に避けることができないのはなぜですか? 次のセクションでは、両者には根本的な違いがあると主張します。 L1には適用できないL2の幅広い最適化を可能にします。

### L1スループットが制限されるのはなぜですか?

残念ながら、L1のブロック制限を解除することは、主要な落とし穴に苦しんでいます。 チェーンの成長率を上げることで、フルノードからの需要も高まります。 最近の状態に追いつこうとしています L1フルノードはすべての履歴を再実行する必要があるので。 ブロックサイズ(気体の面で)が高くなると、それらに大きなひずみがあります。 再び弱いマシンがシステムから脱落し フルノードを走らせる能力を 十分に大きなエンティティにしか残しません 結果として、ユーザーは自分自身で状態を確認し、ネットワークに信頼できなくなります。

これにより、真に分散型でセキュアなシステムを維持するために、L1スループットは制限されるべきであるという理解が私たちに残ります。

### なぜ同じ障壁が有効期間に影響を与えないのですか?

**完全なノードの観点を考慮した場合にのみ、有効性のロールアップによって提供される真の力がわかります。**L1 フル ノードは、現在の状態が正確であることを確認するために、履歴全体を再実行する必要があります。 StarkNetノードはSTARK証明を検証するだけで、この検証には指数関数的に低い計算リソースが必要です。 特に、ゼロからの同期は実行を伴う必要はありません。 ノードは、ピアから現在の状態のダンプを受け取り、この状態が有効であることを STARK 証明でのみ検証します。 これにより、フルノードからの要件を増やすことなく、ネットワークのスループットを向上させることができます。

したがって、L2シーケンサーはL1では不可能な全体の最適化の対象となります。

### パフォーマンス・ロードマップ

次のセクションでは、現在StarkNetシーケンサー用に計画されているものについて説明します。

### シーケンサー並列化

ロードマップの最初のステップは、トランザクション実行に並列化を導入することでした。 これは昨日MainnetでリリースされたStarkNetアルファ0.10.2で導入されました。 我々は今、どのような並列化に飛び込む(これは、半技術的なセクションでは、ロードマップ上で続行するには、次のセクションにジャンプします)。

「トランザクション並列化」とは何を意味するのでしょうか？ 単純に、異なるトランザクションが依存する可能性があるため、トランザクションのブロックを並列実行することは不可能です。 これは次の例で示されています。 同じユーザーからの3つのトランザクションを持つブロックを考えてみましょう:

* トランザクションA：USDCをETHに交換する
* トランザクションB:NFTのETHを支払う
* 取引 C: BTCにUSDTをスワップする

明らかに、Tx AはTx Bより前に起こらなければなりませんが、Tx Cは両方から完全に独立しており、並列に実行することができます。 各トランザクションが実行に1秒を必要とする場合、並列化を導入することでブロックの生産時間を3秒から2秒に短縮できます。

問題の核心は、事前にトランザクションの依存関係がわからないことです。 実際には、例からトランザクションBを実行する場合にのみ、トランザクションAによって行われた変更に依存していることがわかります。 より形式的には、トランザクションAが書き込んだストレージセルからトランザクションBが読み込まれるという事実に基づいています。 取引は依存関係グラフを形成すると考えることができます。 トランザクションAからトランザクションBのiff Aまでエッジがあり、Bによって読み込まれるストレージセルに書き込みます。 Bより前に処刑されなければなりません 次の図は、このような依存関係グラフの例を示しています。

![](https://miro.medium.com/max/641/0*I-qGgxdJJmqmgZWM)

上記の例では、各列を並列に実行できます。 そして、これが最適な配置です(単純に、トランザクションは1~9を順次実行していたでしょう)。

依存グラフが事前にわからないという事実を克服するために、Aptos Labs によって開発された[BLOCK-STM](https://malkhi.com/posts/2022/04/block-stm/)の精神で、StarkNet シーケンサーに***楽観的並列化***を導入します。 このパラダイムの下で、私たちは、トランザクションを並列に実行し、衝突を見つけたときに再実行することを楽観的に試みます。 例えば、Tx4がTx1に依存していることを確認するためにのみ、図1から並列にトランザクション1-4を実行することができます。 したがって、その実行は役に立たなかった(Tx1を実行したのと同じ状態に対して実行した)。 Tx1を適用した結果の状態に対して実行するべきだった。 その場合、Tx4を再実行します。

楽観的な並列化に加えて、多くの最適化を加えることができます。 例えば、単純に各実行が終了するのを待つのではなく、依存関係が無効になった瞬間に実行を中止することができます。

もう1つの例は、どのトランザクションを再実行するかを最適化することです。 図1からのすべてのトランザクションで構成されるブロックが、5つのCPUコアを持つシーケンサーに送られるとします。 最初に、トランザクション1-5を並列実行しようとします。 完了の順序がTx2、Tx3、Tx4、Tx1、そして最終的にTx5であった場合 次に、Tx4がすでに実行された後にのみ依存性Tx1→Tx4が見つかり、再実行される必要があることを示します。 Tx4の新しい実行を与えると異なる動作をする可能性があるため、簡単には、Tx5を再実行したい場合もあります。 ただし、今回の無効化されたTx4以降のすべてのトランザクションを再実行するのではなく。 実行がすでに終了しているトランザクションから構築された依存関係グラフを横断し、Tx4に依存するトランザクションのみを再実行することができます。

### Cairo-VM用の新しいRust実装

StarkNetのスマートコントラクトはカイロで記述されており、カイロVM内で実行され、[カイロ紙](https://eprint.iacr.org/2021/1063.pdf)に記載されている。 現在、シーケンサーはCairo-VMの[Python実装](https://github.com/starkware-libs/cairo-lang/tree/master/src/starkware/cairo/lang/vm)を使用しています。 VMの実装性能を最適化するために、VMをrustで書き直す作業を開始しました。 [Lambdaclass](https://lambdaclass.com/)の素晴らしい仕事に感謝します StarkNetエコシステムの非常に貴重なチームは、この努力はすぐに実現に近づいています。

VMのrust実装、[cairo-rs](https://github.com/lambdaclass/cairo-rs)が、カイロのネイティブコードを実行できるようになりました。 次のステップは、スマートコントラクトの実行とピトニックシーケンサーとの統合です。 cairo-rsと統合されると、シーケンサーのパフォーマンスは大幅に向上すると予想されます。

### Rust におけるシーケンサーの再実装

性能向上のためにpythonからrustに移行したのは、Cairo VMに限られたことではありません。 上記の改良と並んで、シーケンサーを最初から錆で書き直す予定です。 Rust の内部的な利点に加えて、シーケンサーに他の最適化を行う機会を提供します。 カップルをリストアップすると、ピトン-錆の通信のオーバーヘッドなしでcairo-rsの利点を楽しむことができます。 そして、状態が保存されアクセスされる方法を完全に再設計することができます(今日は[Patricia-Trie 構造](https://docs.starknet.io/documentation/develop/State/starknet-state/#state_commitment) に基づいています)。

### 諺についてはどうですか?

この記事を通して、私たちは妥当性ロールアップのおそらく最も有名な要素、すなわちプロバーについて言及していませんでした。 おそらく最も洗練されたアーキテクチャの構成要素であることは、それがボトルネックであり、したがって最適化の焦点であることを想像することができます。 興味深いことに、StarkNetのボトルネックとなったのは、より「標準」のコンポーネントです。 今日、特に[再帰的な証明](https://medium.com/starkware/recursive-starks-78f8dd401025)を使えば、Testnet/Mainnetの現在のトラフィックよりも多くのトランザクションを証拠に収めることができます。 実際には、今日、StarkNetブロックは、後者が時々数十万NFTミントを発生することができるStarkExトランザクションと一緒に証明されています。

### Summary

並列化、Rustなど、今後のStarkNetバージョンで改善されたTPSのために気をつけてください。