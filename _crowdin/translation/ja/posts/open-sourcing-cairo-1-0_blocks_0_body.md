### TL;DR

* **Cairo 1.0 はオープンソースです! これはStarkNetスタックをオープンソース化するための最初のステップに過ぎません。**
* Cairo 1.0 コンパイラに[first look](https://github.com/starkware-libs/cairo)を提示します。 これで、基本的なカイロ1.0コードの実験を開始できます。
* カイロ1.0のコアはRustによく似ています
* リリースではなく、最初の味を考えてみましょう。 さらなる改善が進んでいます。 最初のバージョンのコンパイラは来年のQ1の初めに予定されています。
* Cairo 1.0 は StarkNet ではまだサポートされていません。 来年のQ1でStarkNetでサポートされる予定です。

### はじめに

2020年には、確認可能な計算をサポートするターニングコンプリートプログラミング言語である[Cairo](https://eprint.iacr.org/2021/1063.pdf)をリリースしました。 カイロはアセンブリ言語として始まり、次第に表現力豊かになりました。 2ヶ月前に、現在の状況でいくつかの大きな問題に対処する[Cairo 1.0](https://medium.com/starkware/cairo-1-0-aa96eefb19a0)を発表しました。

* Cairoの構文は創業以来著しく改善されてきましたが、開発者の経験はいつでも改善されます。 カイロ1.0は錆びた完全に型付けされた言語であり、同じロジックを書くことがはるかに簡単で、エラーが発生しやすくなります。
* 既存のコンパイラは StarkNet 自体と同じリポジトリで開発されているため、言語の変更を追跡することが困難になります。 Cairo 1.0 コンパイラは一から書かれており、機能開発の高速化とコミュニティへの関与を促進します。
* すべての計算が証明できるようになりました 現在、Cairo プログラムは特定の入力で失敗する可能性があります (例えば、いくつかの計算ブランチで \`assert 1=2\` 命令に達することによって)、計算を証明できません。 Cairo 1.0 では、あらゆるブランチでプログラムが証明可能です。 これはStarkNetのDOS保護と検閲抵抗のために特に重要です。

本日、我々は、開発を公的レポに移行する上記の目標に達するための最初のマイルストーンをマークします。 そして**オープンソースのカイロ 1. ! ****開発者は、初めて、簡単なカイロ1.0プログラムをコンパイルして実行することができます。 これにより、開発者はCairo 1の実験を開始することができます。 そして、この段階ではまだStarkNetでは実装できない場合でも、徐々に新機能に慣れていきます。</p>

### 現在の機能

現在、基本的なネイティブカイロプログラムをコンパイルし、実行することができます。 構文/言語の改良の多くはまだ進んでいますが、これによりカイロ1.0に慣れ、来るにつれてアップグレードを楽しむことができます。

**StarkNet コントラクトの作成はまだサポートされていないことに注意してください。**StarkNet 構文 (ストレージ変数 / 呼び出しコントラクト / イベントおよびその他のシステム コール) は、今後数週間で追加されます。

### コードの例

古い構文とカイロ1の違いを説明する。 では、n’s Fibonacci 番号を見つけるためのいくつかの異なる実装/フレーバーを表示します。

### 例 I: 一致する式

Cairo 1.0 では、rustlike[match](https://doc.rust-lang.org/rust-by-example/flow_control/match.html?highlight=match#match)を使うことができます。 参照失効を引き起こす可能性のある/else文の場合、あなたはもはや恐れません!

![](/assets/code01.png)

### 例 II: データ型

Cairo 0はフェルトとポインタを扱っていましたが、Cairo 1.0では言語内の複雑なデータ型にネイティブでアクセスすることができます。 以下に、最初のn個のフィボナッチ数の配列を生成する例を示します。

![](/assets/code02.png)

上記のように、メモリポインタを直接操作するのではなく、 `Array:: を使用します。<felt>\`型と\`array_append\`関数。

### 例 III: structs & ownership

次のコードは、カイロ1.0における構造体の使用法を示しています。

![](/assets/code03.png)

> 次の段落は、観客の間でRustaceansのために意味されています。 カイロ1.0は錆と同様の方法でメモリを管理します。 特に、[所有権と借りる](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)の概念を使用します。 したがって、 \`FibResult\` 構造体のメンバにアクセスすることにより、 (この場合は \`result. alue\`), 私たちは \`result\` を移動しました。つまり、 FibResult がコピー可能でない限り、 \`result.index\` 内で再びアクセスできないということです。 これを克服するために、\`FibResult\` 型の \`#\[derive(Copy)\` 属性を追加します。 将来のバージョンでは、構造体の自動解体を追加します。 これにより、他のメンバーに触れることなく、あるメンバーの所有権を移動することができます。 上記のコードは、 \`FibResult\` が copy 属性を持っていなくてもコンパイルされます。

**特に、カイロ1.0はカイロのオリジナルのメモリモデル(確定的な読み取り専用のみ)を完全に抽象化していることに注意してください。**

## 例 IV: 伝播エラー

次のコードはn’s Fibonacci 数を計算しますが、前の例とは異なり、すべての入力は uint128 型です。 これはカイロ0でUintを扱う大きな痛みを解決することに注意してください。 ここで、uint128 (および将来の uint256) はネイティブの型です。

![](/assets/0_s8bhjf_ade3carmi.png)

128 ビットの整数を2つ追加すると、オーバーフローを引き起こす可能性があります。 上記のコードでは、[Option enum](https://doc.rust-lang.org/rust-by-example/std/option.html)と[question mark operator](https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html)を使用して、中間追加のいずれかのオーバーフローの場合を処理します。 サウンドを保証するために \`unit256_check\` 関数を呼び出す必要があった[現在の](https://github.com/starkware-libs/cairo-lang/blob/9889fbd522edc5eff603356e1912e20642ae20af/src/starkware/cairo/common/uint256.cairo#L31)uint256 追加構文と比較します。 また、近い将来には、 言語に \`panic\` という概念を追加します(rustの[punic](https://doc.rust-lang.org/rust-by-example/std/panic.html)マクロに似ています)。 そして、追加のオーバーフローのような単純なエラーは自動的にキャッチ不能になり、自動的に伝播されます。つまり、\`Option\`または\`を使用する必要はありませんか？ ` uintsを追加するとき。

## 自分で試してみてください

現在サポートされているCairo 1.0プログラムをコンパイルして実行できるようになりました。 \`cairo-run\` コマンドの使い方については、以下の[手順](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-runner)に従ってください。 内部では、[Lambdaclass](https://github.com/lambdaclass/cairo-rs)によって開発された[Rust Cairo VM](https://lambdaclass.com/)が実行に使用されていることに注意してください。

[を始めるのに役立つ例はこちら](https://github.com/starkware-libs/cairo2/tree/main/examples) にあります。 これはコンパイラ開発の最初の試みに過ぎないことに注意してください。今後数週間で、コンパイラと一緒にCLIを改善します。

## 今後の予定

Q1の初めに予定されているコンパイラの最初のバージョンの焦点は、カイロ1.0のStarkNetの既存のすべての機能をサポートしています。 さらに、Cairo 1.0 コンパイラの機能拡張にも取り組んでいます。 今後数週間で、あなたは期待できます:

* StarkNet 機能 — スマートコントラクトを作成し、システムコールを使用しています。
* ループ
* 新しいライブラリ関数
* 改善された言語サーバー
* StarkNetガスのネイティブな概念

必ずコンパイラの進行状況を確認してください！