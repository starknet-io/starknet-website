### TL;DR

* **Testnetで手数料が必須になりました。まもなくMainnetで。**
* 契約工場パターンが可能になりました!
* StarkNetがコントラクトクラスを導入しています
* デリゲートコールはライブラリコールに置き換えられます

### はじめに

StarkNet Alpha 0.9.0をご紹介します! これは、StarkNetが成熟に向けて重要なステップを行う重要なバージョンであり、機能とプロトコル設計の両方に実質的な追加が行われます。

**手数料は必須です**(現在は Testnet でのみ、バージョン 0.9 まで)。 ) - 繁栄するL2は、独自の手数料制度を持っている必要があります。 バージョン0.8でオプション機能として手数料を導入した後。 我々は自信を持ってプロトコルのコアコンポーネントとして組み込んで必須にしています 詳細は以下をご覧ください。

プロトコルレベルにおけるもう一つの重要な変更点は、コントラクトクラスとクラス/インスタンスの分離の導入です。 これにより、\`delegate_call\` 機能をより簡単に使用でき、既存の契約からのデプロイが可能になり、StarkNet でファクトリパターンを有効にできます。

### コントラクトクラス

オブジェクト指向プログラミングからインスピレーションを得て、コントラクトコードとその実装を区別します。 契約をクラスやインスタンスに分けることで行います。

**コントラクトクラス**はコントラクトの定義です: そのカイロバイトコード。 ヒント情報、エントリポイント名、そして明確に意味を定義するのに必要なすべて。 各クラスはそのクラスハッシュによって識別されます(OOP言語のクラス名に似ています)。

**contract インスタンス**、または単純なコントラクトは、一部のクラスに対応するデプロイ済みコントラクトです。 contract インスタンスのみがコントラクトとして動作します。つまり、自分のストレージを持っており、トランザクション/その他のコントラクトによって呼び出すことができます。 contract クラスが StarkNet にデプロイされたインスタンスを持っているとは限りません。 クラスの導入には、いくつかのプロトコル変更が付属しています。

#### 「宣言」取引

新しいタイプのトランザクションを StarkNet に導入しています:['declare'](https://docs.starknet.io/docs/Blocks/transactions#declare-transaction)トランザクションで、コントラクト**クラスを宣言できます。**\`deploy\` トランザクションとは異なり、これはそのクラスのインスタンスをデプロイしません。 StarkNetの状態には、宣言されたクラスのリストが含まれます。 新しいクラスは新しい \`declare\` トランザクションで追加できます。

#### 「デプロイ」システムコールと契約工場。

クラスが宣言されると、対応する \`declare\` トランザクションが受け入れられ、そのクラスの新しいインスタンスを展開できます。 このためには、次の引数を取る新しい \`deploy\' システムコールを使用します。

* クラスのハッシュ
* 塩
* コンストラクタ引数

「デプロイ」システムコールはそのコントラクトクラスの新しいインスタンスをデプロイします。 誰の[アドレス](https://docs.starknet.io/docs/Contracts/contract-address)は、上記の 3 つのパラメータと deployer アドレス (システムコールを呼び出したコントラクト) によって決定されます。

呼び出し元のトランザクション内のデプロイを含めると、展開と呼び出しを別の方法で処理することなく、展開の料金と手数料を支払うことができます。 配備手数料の詳細については、[ドキュメント](https://docs.starknet.io/docs/Fees/fee-mechanism#deployed-contracts) を参照してください。

この機能は StarkNet にコントラクト工場を導入します。どんなコントラクトでも \`deploy\` syscall を呼び出すことができるため、新しいコントラクトを作成します。

#### 「代理通話」から「ライブラリ通話」へ移動

クラスの導入により、Ethereumのデリゲートコールメカニズムでよく知られている問題に対処することができます。コントラクトが別のコントラクトにデリゲートコールを実行する場合。 実際のインスタンス(そのストレージ)ではなく、そのクラス(そのコード)だけが必要です。 委任呼び出しを行うときに特定のコントラクトインスタンスを指定する必要があるので、悪い慣行です(実際には、そうではありません)。 それはEthereum契約にいくつかのバグをもたらしました。— クラスのみを指定する必要があります。

古い \`delegate_call\' システムコールは廃止されました(既にデプロイされている古い契約は機能し続けます。 しかし、**\`delegate_call\`を使用するコントラクトはコンパイルされなくなります。**) そして、コントラクトインスタンスアドレスの代わりに(以前に宣言されたクラスの)クラスハッシュを取得する新しいlibrary_callシステムコールに置き換えられます。 ライブラリ呼び出しには実際の契約が 1 つしか関与していないことに注意してください。そのため、呼び出しコントラクトと実装コントラクトのあいまいさを避けます。

#### 新しいAPIエンドポイント

APIに2つの新しいエンドポイントを追加し、クラス関連データの取得を可能にしました。

* \`get_class_by_hash\`: クラスハッシュを与えられたクラス定義を返します
* \`get_class_hash_at\`: コントラクトアドレスを与えられたデプロイされたコントラクトのクラスハッシュを返します

上記の2つのメソッドを通過するのではなく、直接デプロイされたコントラクトのクラスを取得することに注意してください。 以前の \`get_full_contract\' エンドポイントを使用することができ、将来のバージョンでは名前を変更することができます。 上記のすべてのエンドポイントは、[StarkNet CLI](https://docs.starknet.io/docs/CLI/commands) からも使用できます。

#### 手数料

``[invoke](https://docs.starknet.io/docs/blocks/transactions#invoke-function)\`トランザクションでは、StarkNetに手数料を組み込むように進みます。 \`declare\`トランザクションは現時点で手数料を必要としません。 同様に、\`deploy`` トランザクションも手数料を必要としませんが、このトランザクションタイプは将来のバージョンでは非推奨になる可能性が高いことに注意してください。

いくつかの未公開の質問がこの分野に残っています。最も顕著なものは、コントラクト宣言とStarkNetアカウントの展開に手数料を請求する方法です。 将来のバージョンでこれらの問題に取り組んでいきます。

### 次は何ですか？

私たち[が2月に](https://medium.com/starkware/starknet-on-to-the-next-challenge-96a39de7717)に発表したロードマップに従って、私たちはStarkNetのパフォーマンスを全般的に向上させることにコミットしています。 特にシーケンサーのパフォーマンスは、ユーザーが自分のトランザクションについてより速くフィードバックを得るためのものです。 次のバージョンでは、シーケンサーに並列化を導入し、ブロック生成を高速化する予定です。

StarkNetの次のメジャーバージョンは、[ERC-4337](https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a)に似た方法で、StarkNetのアカウントの構造に焦点を当てます。 これにより、StarkNetアカウントのふるまいは、大量採用に向けてさらにもう一つの主要なステップを踏み出します!