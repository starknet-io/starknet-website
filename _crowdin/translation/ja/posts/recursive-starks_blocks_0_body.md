### TL;DR

* 再帰的な証明は Mainnet 上でライブで行われ、StarkEx アプリと StarkNet を単一の証明でスケーリングします。
* 規模を向上させ、コストで利益をもたらします。 そして待ち伏せ（まれでエキサイティングなスケールとレイテンシーがタンデムで移動し、トレードオフではありません）
* これは、L3とその他の利点のための段階を設定しますGoは、[再帰的な証明](https://medium.com/@starkware/recursive-starks-78f8dd401025)のブログ記事を読んでください。 それはクールなもの 😉

### 拡大縮小！

再帰的な証明ーカイロの一般的な計算によって動作します。 これにより、STARKのL2スケーリングのパワーが大幅に向上しました。 単一の証拠を介してEthereumに書き込むことができるトランザクションの数を迅速に増やすことができます。

これまで、STARKスケーリングは数十、数十万件のトランザクションを単一の証明に「ロールアップ」してきました。 Ethereumに書かれていました 再帰的になると、多くのそのような証明が単一の証明に「ロールアップ」されることがあります。

この方法は、現在、Cairoベースの多数のアプリケーションで使用されています。StarkEx、StarkWareのSaaSスケーリングエンジン、および権限なしのロールアップであるStarkNetで実行されているアプリケーションです。

### これまでの話

2020年3月には、Mainnetでの最初の証拠として、以下のような展開がありました。

### STARKベースの拡大縮小

2020年6月には、最初のSTARKベースのスケーリングソリューション ([StarkEx](https://youtu.be/P-qoPVoneQA)) がEthereum Mainnetにデプロイされました。 StarkExには、大規模な計算をオフチェーンで実行し、その正確性のためにSTARKプルーフを生成するプロバーと、この証明をオンチェーンで検証するVerifierがあります。 この最初のデプロイの制約は、StarkWareのエンジニアによる「手書き」であり、StarkExの機能速度を大幅に制限していました。 一般的な計算を証明するためのプログラミング言語が必要であると結論付けました — カイロ。

#### Cairo

2020年の夏、カイロはEthereum Mainnetで[初登場](https://medium.com/starkware/hello-cairo-3cb43b13b209)しました。 Cairo は CPU 代数中級表現 (AIR) の略で、この "CPU" の命令セットを検証する単一の AIR が含まれています。 それはより複雑なビジネスロジックのためのコーディング証明のためのドアを開けました。 より速く安全な方法で行うことができます Cairo プログラムは、単一のアプリケーションのロジックの実行を証明することができます。 しかし、カイロのプログラムは、複数のそのようなアプリケーションの連結にもなり得ます - SHARP。

#### 共有

SHARP(SHARPプローバー)は、いくつかの別々のアプリからトランザクションを取得し、1つのSTARKプルーフでそれらすべてを証明します。 アプリは、より速くSTARK-プルーフの容量を埋めるトランザクションのバッチを組み合わせます。 トランザクションは、速度とレイテンシの向上で処理されます。 次のフロンティア: 再帰的な証明ですが、単にハードコードされたロジックだけではなく、**一般的な計算** のためのものです。

再帰証明の完全な利点を理解するためには、これまでSHARPによってどのように(非再帰的)証明が行われたかについてもう少し理解する価値があります。 典型的な非再帰フローを図1に描画します。

![図面1: 典型的な非再帰的な証明フロー](/assets/recursive_starks_01.png "図面1: 典型的な非再帰的な証明フロー")

ここでは、ステートメントは時間をかけて到着します。 一定の容量(または時間)しきい値に達すると、大きな複合ステートメント(列車)が生成されます。 この組み合わせ文は、すべての個々の文が受信された後にのみ証明されます。 この証明書は証明するのに長い時間がかかります(それぞれの声明を個別に証明するのにかかる時間の概算)。

非常に大きなステートメントを証明することは、メモリなどの利用可能なコンピューティングリソースによって最終的に制限されます。 再帰に先立ち、これは事実上STARK証明の限界スケーラビリティ障壁でした。

### 再帰プロビングとは何ですか?

STARK証明では、ステートメントを実行するのにかかる時間は、大体直線的であることを証明します。 さらに、ステートメントを証明するにはTに時間がかかる場合、証明を証明するには、大体のログ(T)時間がかかります。これは通常、「対数圧縮」と呼ばれます。 言い換えれば、STARKsでは、それを計算するよりもステートメントを検証するのにはるかに少ない時間を費やす。

[Cairo](https://starkware.co/cairo/)は、STARK証明書で証明し、対応するSTARK検証器で検証できる一般的な計算文を表現することができます。

ここで、[再帰](https://en.wikipedia.org/wiki/Recursion)を実行する機会が始まります: 私たちが数千の取引の正しさを証明するカイロプログラムを書くのと同じように。 また、複数のSTARK証明を検証するカイロプログラムを書くこともできます。 複数の「上流」証明の有効性を証明する単一の証明を生成することができます。 これは私たちが「再現的な証明」と呼んでいるものです

対数圧縮とほぼ直線的な証明時間のために。 STARK証明を証明するには、比較的短い時間がかかります(近い将来、わずか数分であることが予想されます)。

再帰を実装する場合、SHARPは到着時に声明を証明することができます。 それらの証明は、さまざまなパターンの再帰的な証明に何度もマージすることができます。 ある時点でその証明書は チェーン上の検証契約に提出されます 典型的なパターンは図2に示されています。

![Drawing 2: 典型的な再帰的な証明フロー。](/assets/recursive_starks_02.png "Drawing 2: 典型的な再帰的な証明フロー。")

### 再帰証明の即時利点

#### チェーン内コストの削減

コウモリを離れて、複数の証明の「圧縮」を1つにします。 これは、トランザクションあたりのオンチェーン検証コストを下げることを意味します(各ステートメントには多くのトランザクションが含まれる場合があります)。

再帰では、計算リソースバリア（例えば、 それぞれの限られたサイズステートメントは別々に証明することができるので、これまでの限られた証明のサイズが削除されます。 したがって、再帰を使用する場合、再帰の実効列車サイズはほぼ制限されておらず、トランザクションあたりのコストを桁違いに削減することができます。

実用的な用語では、減少は許容待ち時間(およびトランザクションが到着する速度)によって異なります。 さらに、各プルーフは通常、オンチェーンデータなどのいくつかの出力を伴うので。 1つの証拠と一緒にチェーンに書き込めるデータの量に制限がある それにもかかわらず、コストを一桁削減し、さらに良いことは些細なことに達成できます。

#### レイテンシの減少

再帰的な証明パターンは、大規模な文の列を証明するレイテンシを低減します。 これは 2 つの要因の結果です:

1. 受信文は**を並列で証明することができます**(非常に大きな複合文を証明するのとは対照的です)。
2. 列車内の最後の声明が証明し始めるまで待つ必要はありません。 むしろ、証明は到着時に新しい声明と組み合わせることができます。 これは、Trainに参加する最後のステートメントのレイテンシーを意味します。 は、繰り返し検証明書が発行されるまでにかかる時間に加えて、完全に最後の文であることを証明するのにかかる時間です(この列車に搭載されているすべての文に証明されます)。

私たちは、再帰検証明書の遅延を積極的に開発し、最適化しています。 私達は、これが数ヶ月以内に数分の順序に達すると予想します。 したがって、効率的なSHARPは数分から数時間までの待ち時間を提供することができます。 取引ごとのトレードオフとチェーンコストに応じて異なります これは、SHARPのレイテンシに有意義な改善をもたらします。

#### L3を容易にする

カイロでの再帰検証明書の開発はまたStarkNetに証明を提出する可能性を開きます。 その声明はStarkNetスマートコントラクトに焼くことができるように。 これにより、パブリックStarkNet[(L2ネットワーク) 上に](https://medium.com/starkware/fractal-scaling-from-l2-to-l3-7fe238ecfb4f)L3デプロイメントを構築することができます。

再帰的なパターンは、L3からの証明の集計にも適用され、L2上の単一の証明によって検証されます。 したがって、ハイパースケーリングも達成されます。

### もっと豪華な利点

#### 適用される再帰性

再帰は、さらにコストとパフォーマンスを拡大したいと考えているプラットフォームやアプリケーションにさらに多くの機会を開きます。

各 STARK 証明書は、「公開入力」(またはカイロの用語で「プログラム出力」)と呼ばれるいくつかの入力に適用される文の有効性を証明します。 概念的に、STARKは2つの証明を*2つの*入力を2つの*入力を1つの*プルーフに圧縮します。 言い換えれば、証明の数が減る一方で、入力の数は一定に保たれます。 これらの入力は通常、L1の状態を更新するためにアプリケーションによって使用されます(e. をクリックします。

再帰ステートメントが*アプリケーション対応*であることが許可されている場合、つまり、アプリケーション自体のセマンティクスを認識している場合、2 つの証明を 1 つに圧縮することも*、*つの入力を 1 つに結合することもできます。 生成された文は、アプリケーションのセマンティクスに基づく入力の組み合わせの妥当性を証明します。 したがって、Applicative Recursionという名前です (例えば図面3を参照してください)。

![図面3: 適用再帰の例](/assets/recursive_starks_03.png "図面3: 適用再帰の例")

ここで、ステートメント1はAからBへの状態アップデートを証明し、ステートメント2はBからCへのさらなるアップデートを証明します。 ステートメント1およびステートメント2の校正は、AからCへの直接の更新を証明する、3番目のステートメントに結合することができます。 同様のロジックを再帰的に適用することで、ステートアップデートのコストを最終待ち時間要件まで大幅に削減できます。

Applicative Recursion のもう一つの重要な例は、複数の証明から積み上げデータを圧縮することです。 たとえば、StarkNetなどの妥当性ロールアップの場合。 L2のすべてのストレージアップデートは、データの可用性を確保するためにL1の伝送データとしても含まれています。 ただし、同じストレージ要素に複数の更新を送信する必要はありません。 証明された証明によって証明された取引の最終的な価値のみがデータの可用性に必要とされるので。 この最適化はすでに*単一の*StarkNetブロック内で実行されています。 しかし、ブロックごとの証明を生成することによって、Applicative Recursion は、この積み上げデータを**L2ブロックにわたって圧縮する可能性があります。 これにより、L1アップデートのスケーラビリティを犠牲にすることなく、大幅なコスト削減を実現し、L2上のブロック間隔を短縮することができます。

注目すべき点: 応用再帰は、前述のようにアプリケーション不可知論的再帰と組み合わせることができる。 この２つの最適化は独立しています

#### チェーン上での確認の複雑さの減少

STARK 検証機の複雑さは、検証するために設計された文の種類によって異なります。 特に、Cairo 文の場合、検証の複雑さは、Cairo 言語で許可される特定の要素に依存します。 さらに具体的には、サポートされている組み込みイン(CairoにCPUメタファーを使用する場合) 次に、内蔵されたインは、CPU内のマイクロ回路と同等のものです:非常に頻繁に行われる計算は、独自の最適化された計算を必要とします)。

カイロ言語は進化を続けており、ますます便利なビルトインを提供しています。 一方、Recursive Verifierでは、これらの組み込みインの小さなサブセットを使用するだけです。 したがって、再帰的なSHARPは、再帰的な検証器で完全な言語をサポートすることによって、カイロのあらゆる文をうまくサポートすることができます。 具体的には、L1 Solidity Verifierは再帰的な証明を検証するだけです。 したがって、カイロ言語のより安定したサブセットに限定することができます。L1検証器は、最新かつ最大の組み込みインに追いつく必要はありません。 言い換えれば、進化し続ける複雑な文の検証はL2に追いやられ、L1検証器はよりシンプルで安定した文を検証します。

#### 縮小された足跡の計算

再帰の前 複数の文を1つの証明に集約する能力は、利用可能な計算インスタンス(およびそのような証明を生成するのにかかる時間)で証明できる文の最大サイズによって制限されました。

再帰では、このような極めて大きな文を証明する必要はなくなりました。 結果として、小さく、 より安価で利用可能なコンピューティングインスタンスを使用することができます(ただし、それらの多くは大きなモノリシックな諺よりも必要になる可能性があります)。 これにより、従来よりも物理的および仮想的な環境におけるprover インスタンスのデプロイが可能になります。

### Summary

全般的な計算の再帰的な証明は、Mainnet EthereumでStarkNetを含む複数の生産システムに使用されるようになりました。

再帰の利点は、新たな改善を引き続き可能にするため、徐々に実現されるでしょう。 そしてまもなく、並列化の可能性を解放することで、ハイパースケールのガス料金を削減し、レイテンシを向上させることになります。

それは、L3やアプリケーション再帰などの新しい機会とともに、大きなコストとレイテンシの利点をもたらします。 再帰検証器のさらなる最適化は進行中であり、より優れた性能とコスト面でのメリットが時間の経過とともに提供されることが期待されます。



**Gidi Kaempfer**, コアエンジニアリングヘッド, StarkWare