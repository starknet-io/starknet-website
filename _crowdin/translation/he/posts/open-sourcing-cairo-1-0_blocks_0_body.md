### TL;DR

* **Cairo 1.0 הוא קוד פתוח! זהו רק הצעד הראשון לקראת מיקוד פתוח של מחסנית StarkNet.**
* כעת אנו מציגים[מבט ראשון](https://github.com/starkware-libs/cairo)לתוך המהדר של קהיר 1.0. כעת תוכל להתחיל להתנסות בקוד Cairo 1.0 בסיסי
* Cairo 1.0 בבסיסו דומה מאוד ל-Rust
* ראה בזה טעימה ראשונה, לא שחרור. שיפורים נוספים בדרך. הגרסה הראשונה של המהדר מתוכננת לתחילת הרבעון הראשון בשנה הבאה.
* קהיר 1.0 עדיין לא נתמך ב-StarkNet. זה יהיה נתמך ב-StarkNet ברבעון הראשון בשנה הבאה.

### הקדמה

בשנת 2020, שחררנו את[Cairo](https://eprint.iacr.org/2021/1063.pdf), שפת תכנות מלאה של Turing התומכת בחישוב שניתן לאימות. קהיר התחילה כשפת אסמבלים והפכה בהדרגה ליותר אקספרסיבית. לפני חודשיים הכרזנו על[Cairo 1.0](https://medium.com/starkware/cairo-1-0-aa96eefb19a0), שמתייחס לכמה בעיות מרכזיות במצב הנוכחי:

* בעוד שהתחביר של קהיר ראה שיפור משמעותי מאז הקמתו, חווית המפתח תמיד יכולה להשתפר. Cairo 1.0 היא שפה בהקלדה מלאה בהשראת חלודה, מה שהופך את הכתיבה של אותו היגיון להרבה יותר קל ופחות נוטה לשגיאות.
* המהדר הקיים פותח באותו ריפו כמו StarkNet עצמו, מה שמקשה על מעקב אחר שינויים בשפה. המהדר של Cairo 1.0 נכתב מהיסוד, ומאפשר פיתוח תכונות מהיר יותר ומעורבות רבה יותר בקהילה.
* כעת ניתן להוכיח כל חישוב. נכון לעכשיו, תוכנית קהיר עלולה להיכשל עם קלט ספציפי (למשל על ידי הגעה להוראה \`assert 1=2\` בענף חישוב כלשהו), מה שהופך את החישוב לבלתי ניתן להוכחה. עם Cairo 1.0, תוכניות ניתנות להוכחה בכל ענף אפשרי. זה חשוב במיוחד להגנת DOS ולהתנגדות לצנזורה ב-StarkNet.

היום אנו מציינים את אבן הדרך הראשונה בהשגת היעדים הנ"ל כאשר אנו מעבירים את הפיתוח לריפו ציבורי, ו**קוד פתוח Cairo 1.0!**מפתחים יכולים כעת, לראשונה, לקמפל ולהפעיל תוכניות פשוטות של Cairo 1.0. זה מאפשר למפתחים להתחיל להתנסות בקהיר 1.0 ולהתרגל בהדרגה לתכונות החדשות, גם אם בשלב זה, הם לא יכולים ליישם את זה ב-StarkNet עדיין.

### היכולות הנוכחיות

נכון לעכשיו, אתה יכול להרכיב ולהפעיל תוכניות מקוריות בקהיר. בעוד שרבים משיפורי התחביר/שפה עדיין בעיצומם, זה מאפשר להתרגל לקהיר 1.0 וליהנות משדרוגים ככל שהם מגיעים.

**שימו לב שכתיבת חוזי StarkNet עדיין לא נתמכת.**תחביר StarkNet (משתני אחסון / חוזי שיחות / אירועים ושיחות מערכת אחרות) יתווסף בשבועות הקרובים.

### דוגמאות קוד

כדי להמחיש את ההבדלים בין התחביר הישן לקהיר 1.0, בחרנו להציג כמה יישומים/טעמים שונים של מציאת מספר פיבונאצ'י ה-n'.

### דוגמה I: התאמת ביטויים

בקהיר 1.0, אתה יכול להשתמש בביטויים דמויי חלודה[match](https://doc.rust-lang.org/rust-by-example/flow_control/match.html?highlight=match#match). לא תחששו עוד מהצהרות שעלולות לגרום לביטול הפניה!

![](/assets/code01.png)

### דוגמה ב': סוגי נתונים

בעוד Cairo 0 עבד עם לבדים ומצביעים, בקהיר 1.0 יש לנו גישה מקורית לסוגי נתונים מורכבים בשפה. להלן ניתן למצוא דוגמה שמייצרת מערך של n מספרי פיבונאצ'י הראשונים.

![](/assets/code02.png)

כפי שניתן לראות לעיל, במקום לעבוד ישירות עם מצביעי זיכרון, אנו משתמשים במערך::<felt>סוג \` והפונקציה \`array_append\`.

### דוגמה III: מבנה & בעלות

הקוד הבא ממחיש את השימוש במבנים בקהיר 1.0.

![](/assets/code03.png)

> הפיסקה הבאה מיועדת ל-Rustaceans בקרב הקהל. Cairo 1.0 מנהל את הזיכרון בצורה דומה לחלודה. בפרט, הוא משתמש במושגים של[בעלות והשאלה](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html). לפיכך, על ידי גישה לחבר במבנה \`FibResult\` (במקרה זה, \`result.value\`), העברנו את \`result\`, מה שאומר שאם לא ניתן להעתיק את FibResult, אנחנו לא יכולים גש אליו שוב ב-\`result.index\`. כדי להתגבר על זה, אנו מוסיפים את התכונה \`#\[derive(Copy)]\` מסוג \`FibResult\`. בגרסאות עתידיות, נוסיף פירוק אוטומטי עבור מבנים. זה יאפשר העברת בעלות על חבר אחד מבלי לגעת באחרים (במיוחד, הקוד שלמעלה היה קומפילציה גם אם ל\`FibResult\` לא הייתה את תכונת העתק).

**במיוחד, שים לב שקהיר 1.0 מפשט לחלוטין את מודל הזיכרון המקורי (ללא קריאה בלבד) של קהיר.**

## דוגמה IV: הפצת שגיאות

הקוד הבא מחשב את מספר פיבונאצ'י ה-n', אך בניגוד לדוגמאות הקודמות, כל הכניסות הן מהסוג uint128. שים לב שזה פותר את נקודת הכאב העיקרית בטיפול ביחידות בקהיר 0. כאן, uint128 (ובעתיד uint256) הם טיפוסים מקומיים.

![](/assets/0_s8bhjf_ade3carmi.png)

תוספת של שני מספרים שלמים של 128 סיביות עלולה לגרום לגלישה. הקוד שלמעלה משתמש ב[Option enum](https://doc.rust-lang.org/rust-by-example/std/option.html)ואופרטור סימן שאלה[](https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html)כדי לטפל במקרה של הצפה באחת מהתוספות הביניים. השווה זאת לתחביר התוספת הנוכחי</a>

, שבו היה צריך לקרוא לפונקציה \`unit256_check\` כדי להבטיח תקינות. בנוסף, בעתיד הקרוב נוסיף את המושג \`פאניק\` לשפה (בדומה למאקרו[panic](https://doc.rust-lang.org/rust-by-example/std/panic.html)בחלודה), ושגיאות פשוטות כמו הצפה של תוספת לא יהיו ניתנות לתפיסה ולהתפשטות אוטומטית, מה שאומר ש. לא תצטרך להשתמש ב-\`Option\` או \`?\` בעת הוספת uints.</p> 



## נסה זאת בעצמך

כעת אתה יכול לקמפל ולהפעיל תוכניות Cairo 1.0 הנתמכות כעת! עקוב אחר[ההוראות האלה](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-runner)כיצד להשתמש בפקודה \`cairo-run\`. שימו לב שמתחת למכסה המנוע, ה[Rust Cairo VM](https://github.com/lambdaclass/cairo-rs), שפותח על ידי[Lambdaclass](https://lambdaclass.com/), משמש לביצוע.

תוכל למצוא דוגמאות נוספות שיעזרו לך להתחיל[כאן](https://github.com/starkware-libs/cairo2/tree/main/examples). שימו לב שזו רק ההצצה הראשונה לפיתוח המהדר; בשבועות הקרובים נשפר את ה-CLI לצד המהדר.



## תוכניות עתידיות

המוקד של הגרסה הראשונה של המהדר, שמתוכננת לראשית הרבעון הראשון, הוא תמיכה בכל הפונקציונליות הקיימת של StarkNet בקהיר 1.0. בנוסף, אנו עובדים על הרחבת היכולות של המהדר Cairo 1.0. בשבועות הקרובים תוכלו לצפות:

* יכולות StarkNet - כתיבת חוזים חכמים ושימוש בשיחות מערכת.
* לולאות
* פונקציות חדשות בספרייה
* שרת שפה משופר
* רעיון מקורי של גז StarkNet

הקפד להישאר מעודכן ולעקוב אחר התקדמות המהדר!