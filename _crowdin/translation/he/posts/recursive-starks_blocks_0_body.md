### TL;DR

* הוכחה רקורסיבית פעילה ב-Mainnet, ומרחיבה את אפליקציות StarkEx כמו גם StarkNet עם הוכחה אחת
* זה מגביר את קנה המידה, ומספק תועלת בעלות ובהשהיה (אירוע נדיר ומרגש של קנה מידה והשהייה נעים במקביל, ואינם מהווה פשרה)
* זה מכין את הבמה ל-L3 והטבות אחרות. קרא את הפוסט בבלוג ב[Recursive Proving](https://medium.com/@starkware/recursive-starks-78f8dd401025). זה דברים מגניבים 😉

### מתגבר!

הוכחות רקורסיביות - המופעלות על ידי החישוב הכללי של קהיר - נמצאות כעת בייצור. זה מסמן דחיפה משמעותית לעוצמת קנה המידה של L2 עם STARKs. זה יספק במהירות גידול פי שניים במספר העסקאות שניתן לכתוב ל-Ethereum באמצעות הוכחה אחת.

עד כה, קנה המידה של STARK עבד על ידי "גלגול" של עשרות או אפילו מאות אלפי עסקאות להוכחה אחת, שנכתבה ל-Ethereum. בעזרת רקורסיה, ניתן "לגלגל" הוכחות רבות כאלה להוכחה אחת.

שיטה זו נמצאת כעת בייצור עבור מספר רב של יישומים מבוססי קהיר: אפליקציות הפועלות על StarkEx, מנוע קנה המידה של SaaS של StarkWare ו-StarkNet, האוסף חסר ההרשאות.

### הסיפור עד כה

מאז ההוכחה הראשונה ב-Mainnet, במרץ 2020, ההתפתחויות הבאות עיצבו את אופן השימוש ב-STARKs.

### קנה מידה מבוסס STARK

ביוני 2020 פתרון קנה המידה הראשון מבוסס STARK -[StarkEx](https://youtu.be/P-qoPVoneQA)- נפרס על Ethereum Mainnet. ל-StarkEx יש Prover שמבצע חישובים גדולים מחוץ לשרשרת ומייצר הוכחת STARK לנכונותם, ו-Verifier שמאמת את ההוכחה הזו על-שרשרת. האילוצים לפריסה ראשונה זו נכתבו בכתב יד על ידי המהנדסים של StarkWare, ובכך הגבילו מאוד את מהירות התכונה עבור StarkEx. הגענו למסקנה שיש צורך בשפת תכנות שתתמוך בהוכחת חישוב כללי - קהיר.

#### קהיר

בקיץ 2020 קהיר הופיעה[ב-Ethereum Mainnet](https://medium.com/starkware/hello-cairo-3cb43b13b209). קהיר מייצג CPU Algebraic Intermediate Representation (AIR), וכולל AIR יחיד המאמת את ערכת ההוראות של "CPU" זה. זה פתח את הדלת לקידוד הוכחות ללוגיקה עסקית מורכבת יותר, להצהרות חישוביות שרירותיות ולעשות זאת בצורה מהירה ובטוחה יותר. תוכנית קהיר יכולה להוכיח את ביצוע ההיגיון של יישום יחיד. אבל תוכנית קהיר יכולה להיות גם שרשור של מספר יישומים כאלה - SHARP.

#### חַד

SHARP - SHARed Prover - לוקח עסקאות מכמה אפליקציות נפרדות, ומוכיח את כולן בהוכחת STARK אחת. אפליקציות משלבות את קבוצות העסקאות שלהן, וממלאות את הקיבולת של הוכחות STARK מהר יותר. עסקאות מעובדות בקצב משופר ובאיחור. הגבול הבא: הוכחות רקורסיביות, אבל לא רק עבור לוגיקה מקודדת קשה, אלא עבור**חישוב כללי**.

כדי להבין את התועלת המלאה של הוכחה רקורסיבית, כדאי להבין קצת יותר כיצד הוכחה (לא רקורסיבית) בוצעה על ידי SHARP עד כה. ציור 1 מתאר זרימה טיפוסית לא רקורסיבית:

![ציור 1: זרימת הוכחה אופיינית לא רקורסיבית](/assets/recursive_starks_01.png "ציור 1: זרימת הוכחה אופיינית לא רקורסיבית")

כאן מגיעות הצהרות עם הזמן. כאשר מגיעים לסף קיבולת (או זמן) מסוים, נוצרת הצהרה משולבת גדולה (המכונה גם Train). הצהרה משולבת זו מוכחת רק לאחר שהתקבלו כל ההצהרות הבודדות. להוכחה זו לוקח הרבה זמן להוכיח (בערך סכום הזמן שלוקח להוכיח כל משפט בנפרד).

הוכחת הצהרות גדולות במיוחד מוגבלת בסופו של דבר על ידי משאבי מחשוב זמינים כגון זיכרון. לפני הרקורסיה, זה היה למעשה מחסום המדרגיות המגביל של הוכחת STARK.

### מהי הוכחה רקורסיבית?

עם הוכחות STARK, הזמן שלוקח להוכיח הצהרה הוא ליניארי בערך עם הזמן שלוקח לביצוע ההצהרה. בנוסף, אם הוכחת משפט לוקח זמן T, אז אימות ההוכחה לוקח בערך זמן log(T), אשר נקרא בדרך כלל "דחיסה לוגריתמית". במילים אחרות, עם STARKs אתה משקיע הרבה פחות זמן על אימות ההצהרה מאשר על חישובה.

[Cairo](https://starkware.co/cairo/)מאפשר להביע הצהרות חישוביות כלליות שניתן להוכיח על ידי הוכחות STARK ולאימות על ידי מאמת STARK המקבילים.

כאן מתחילה ההזדמנות לבצע[רקורסיה](https://en.wikipedia.org/wiki/Recursion): באותו אופן שבו אנו כותבים תוכנית קהיר שמוכיחה את נכונותן של אלפי עסקאות, נוכל לכתוב גם תוכנית קהיר שמאמתת מספר הוכחות STARK. אנו יכולים ליצור הוכחה אחת המעידה על תקפותן של הוכחות "במעלה הזרם" מרובות. זה מה שאנו מכנים הוכחה רקורסיבית.

בגלל הדחיסה הלוגריתמית וזמן ההוכחה ליניארי בערך, הוכחת אימות של הוכחה STARK לוקחת זמן קצר יחסית (צפוי להיות דקות ספורות בזמן הקרוב).

בעת יישום רקורסיה, SHARP יכול להוכיח הצהרות עם הגעתם. ניתן למזג את ההוכחות שלהם שוב ושוב להוכחות רקורסיביות בדפוסים שונים עד שבשלב מסוים ההוכחה המתקבלת מוגשת לחוזה מאמת על שרשרת. תבנית טיפוסית מתוארת בשרטוט 2:

![ציור 2: זרימת הוכחה רקורסיבית טיפוסית.](/assets/recursive_starks_02.png "ציור 2: זרימת הוכחה רקורסיבית טיפוסית.")

### יתרונות מיידיים של הוכחה רקורסיבית

#### עלות רשת מופחתת

באופן קבוע, אנו משיגים "דחיסה" של מספר הוכחות לאחת, מה שמרמז על עלות אימות בשרשרת נמוכה יותר לכל עסקה (כאשר כל הצהרה עשויה לכלול עסקאות רבות).

עם הרקורסיה, מחסום המשאבים החישוביים (למשל זיכרון) שהגביל את גודל ההוכחות עד כה, מתבטל, מכיוון שניתן להוכיח כל הצהרת גודל מוגבל בנפרד. מכאן שכאשר משתמשים ברקורסיה, גודל הרכבת האפקטיבי של הרקורסיה הוא כמעט בלתי מוגבל, וניתן להפחית את העלות לעסקה בסדרי גודל.

מבחינה מעשית, ההפחתה תלויה בהשהייה המקובלת (ובקצב הגעת העסקאות). בנוסף, מכיוון שלרוב כל הוכחה מלווה גם בפלט כלשהו כגון נתונים על השרשרת, יש מגבלות לכמות הנתונים שניתן לכתוב על השרשרת יחד עם הוכחה אחת. עם זאת, הפחתת עלויות בסדר גודל ואף טוב יותר היא ניתנת להשגה טריוויאלית.

#### חביון מופחת

דפוס ההוכחה הרקורסי מפחית את ההשהיה של הוכחת רכבות גדולות של הצהרות. זו תוצאה של שני גורמים:

1. ניתן להוכיח הצהרות נכנסות**במקביל**(בניגוד להוכחת משפט משולב גדול במיוחד).
2. אין צורך לחכות עד שתגיע ההצהרה האחרונה ברכבת כדי להתחיל להוכיח. במקום זאת, ניתן לשלב הוכחות עם הצהרות חדשות כשהן מגיעות. משמעות הדבר היא שההשהיה של ההצהרה האחרונה שמצטרפת לרכבת, היא בערך הזמן שלוקח להוכיח את ההצהרה האחרונה שלו בתוספת הזמן שלוקח להוכיח הצהרה רקורסיבית (מה שמעיד על כל ההצהרות שכבר "עלו לסיפון" זה רכבת מסוימת).

אנו מפתחים ומייעלים באופן פעיל את זמן האחזור של הוכחת הצהרת ה-Recursive Verifier. אנו מצפים שזה יגיע לסדר של כמה דקות בתוך כמה חודשים. לפיכך, SHARP יעיל ביותר יכול להציע השהיות ממספר דקות עד כמה שעות, בהתאם לשינוי מול עלות השרשרת לעסקה. זה מייצג שיפור משמעותי לזמן האחזור של SHARP.

#### מקל על L3

הפיתוח של הצהרת ה-Recursive Verifier בקהיר פותחת גם את האפשרות להגיש הוכחות ל-StarkNet, מכיוון שניתן לאפות את ההצהרה הזו בחוזה חכם של StarkNet. זה מאפשר לבנות[פריסות L3 על גבי ה-StarkNet](https://medium.com/starkware/fractal-scaling-from-l2-to-l3-7fe238ecfb4f)הציבורי (רשת L2).

הדפוס הרקורסי חל גם על צבירה של הוכחות מ-L3, שיאומת על ידי הוכחה יחידה ב-L2. מכאן שגם שם מושגת קנה מידה יתר.

### יתרונות עדינים יותר

#### רקורסיה אפליקטיבית

הרקורסיה פותחת עוד יותר הזדמנויות לפלטפורמות ויישומים המעוניינים להרחיב את העלות והביצועים שלהם.

כל הוכחה STARK מעידה על תקפותה של הצהרה שהושמה על קלט כלשהו המכונה "קלט ציבורי" (או "פלט תוכנית" במונחי קהיר). מבחינה קונספטואלית, רקורסיה של STARK דוחסת שתי הוכחות עם*שתי כניסות*ל*הוכחה אחת*עם שתי כניסות. במילים אחרות, בעוד שמספר ההוכחות מצטמצם, מספר התשומות נשמר קבוע. כניסות אלה משמשות אז בדרך כלל על ידי יישום על מנת לעדכן מצב כלשהו ב-L1 (למשל כדי לעדכן שורש מצב או לבצע משיכה על השרשרת).

אם מותר להצהרה הרקורסיבית להיות*app-aware*, כלומר מזהה את הסמנטיקה של היישום עצמו, היא יכולה גם לדחוס שתי הוכחות ל*אחת וגם*לשלב את שני הקלטים לאחד. ההצהרה המתקבלת מעידה על תקפות שילוב הקלט בהתבסס על סמנטיקה של היישום, ומכאן השם רקורסיה אפליקטיבית (ראה ציור 3, לדוגמא).

![ציור 3: דוגמה לרקורסיה אפליקטיבית](/assets/recursive_starks_03.png "ציור 3: דוגמה לרקורסיה אפליקטיבית")

כאן, הצהרה 1 מעידה על עדכון מצב מ-A ל-B והצהרה 2 מעידה על עדכון נוסף מ-B ל-C. ניתן לשלב הוכחות של הצהרה 1 והצהרה 2 להצהרה שלישית, המעידה על העדכון הישיר מ-A ל-C על ידי יישום לוגיקה דומה באופן רקורסיבי, ניתן להפחית את העלות של עדכוני מצב באופן משמעותי עד לדרישת ההשהיה הסופית.

דוגמה חשובה נוספת לרקורסיה אפליקטיבית היא דחיסת נתוני אוסף ממספר הוכחות. לדוגמה, עבור אוסף תוקף כגון StarkNet, כל עדכון אחסון ב-L2 כלול גם כנתוני שידור ב-L1, כדי להבטיח זמינות נתונים. עם זאת, אין צורך לשלוח עדכונים מרובים עבור אותו רכיב אחסון, מכיוון שרק הערך הסופי של העסקאות המעיד על ידי ההוכחה המאומתת נדרש לזמינות הנתונים. אופטימיזציה זו כבר מבוצעת בתוך*בלוק יחיד*StarkNet. עם זאת, על ידי יצירת הוכחה לכל בלוק, רקורסיה אפליקטיבית עשויה לדחוס את נתוני האוסף הזה על פני*מספר בלוקים*L2. זה יכול לגרום להפחתת עלויות משמעותית, ולאפשר מרווחי חסימה קצרים יותר ב-L2, מבלי להקריב את המדרגיות של עדכוני L1.

ראוי לציין: רקורסיה אפליקטיבית עשויה להיות משולבת עם רקורסיה אפליקטיבית-אגנוסטית כפי שתואר קודם לכן. שתי האופטימיזציות הללו אינן תלויות.

#### מורכבות מופחתת של מאמת על שרשרת

המורכבות של מאמת STARK תלויה בסוג ההצהרות שהוא נועד לאמת. בפרט, עבור הצהרות קהיר, מורכבות המאמת תלויה באלמנטים הספציפיים המותרים בשפת קהיר, וליתר דיוק, המובנים הנתמכים (אם אנו משתמשים במטאפורת ה-CPU עבור קהיר, אז המובנים הם מקבילים למיקרו -מעגלים במעבד: חישובים המבוצעים בתדירות כה גבוהה שהם דורשים חישוב אופטימלי משלהם).

שפת קהיר ממשיכה להתפתח ולהציע יותר ויותר מובנים מובנים. מצד שני, ה-Recursive Verifier דורש רק שימוש בתת-קבוצה קטנה של המובנים הללו. לפיכך, SHARP רקורסיבי יכול לתמוך בהצלחה בכל הצהרה בקהיר על ידי תמיכה בשפה המלאה במאמתים רקורסיביים. באופן ספציפי, L1 Solidity Verifier צריך רק לאמת הוכחות רקורסיביות, ולכן ניתן להגביל אותו לתת-קבוצה יציבה יותר של שפת קהיר: L1 Verifier לא צריך להתעדכן עם המובנים העדכניים והטובים ביותר. במילים אחרות, אימות של הצהרות מורכבות המתפתחות ללא הרף נדחק ל-L2, מה שמשאיר את L1 Verifier לאמת הצהרות פשוטות ויציבות יותר.

#### טביעת רגל מחשוב מופחתת

לפני הרקורסיה, היכולת לצבור הצהרות מרובות להוכחה אחת הוגבלה על ידי הגודל המקסימלי של ההצהרה שניתן להוכיח במופעי מחשוב זמינים (והזמן שעלול לקחת ליצירת הוכחות כאלה).

עם הרקורסיה, אין עוד צורך להוכיח אמירות כה גדולות. כתוצאה מכך, ניתן להשתמש במופעי מחשוב קטנים יותר, פחות יקרים וזמינים יותר (אם כי ייתכן שיהיה צורך ביותר מאלה מאשר עם מוכיחים מונוליטיים גדולים). זה מאפשר פריסה של מופעי מוכח בסביבות פיזיות ווירטואליות יותר ממה שהיה אפשר בעבר.

### סיכום

הוכחות רקורסיביות של חישוב כללי משרתות כעת מערכות ייצור מרובות, כולל StarkNet, ב- Mainnet Ethereum.

היתרונות של הרקורסיה יתממשו בהדרגה, ככל שהיא תמשיך לאפשר שיפורים חדשים, והיא תספק בקרוב קנה מידה יתר, תקצץ בעמלות הגז ותשפר את השהייה על ידי פתיחת פוטנציאל ההקבלה.

זה יביא איתו יתרונות משמעותיים בעלות והשהייה, יחד עם הזדמנויות חדשות כמו L3 ורקורסיה אפליקטיבית. אופטימיזציה נוספת של ה-Recursive Verifier נמשכת, וביצועים טובים יותר ויתרונות עלות צפויים להינתן לאורך זמן.



**Gidi Kaempfer**, ראש תחום הנדסת ליבה, StarkWare